<!DOCTYPE html><html><head>
  <style>
    /*! ADAPTED
    Typeplate : Starter Kit
    URL ........... http://typeplate.com
    Version ....... 3.0.2
    Github ........ https://github.com/typeplate/starter-kit
    Authors ....... Dennis Gaebel (@gryghostvisuals) & Zachary Kain (@zakkain)
    License ....... Creative Commmons Attribution 3.0
    License URL ... https://github.com/typeplate/starter-kit/blob/master/license.txt
    */

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      text-rendering: optimizeLegibility;
      line-height: 1;
      margin-top: 0;
      color: #222;
    }

    blockquote+figcaption cite {
      display: block;
      font-size: inherit;
      text-align: right;
    }

    body {
      word-wrap: break-word;
    }

    pre code {
      word-wrap: normal;
    }

    body {
      -webkit-hyphens: auto;
      -ms-hyphens: auto;
      hyphens: auto;
      color: #444;
    }
	
	figcaption {
		text-align: center;
	}

    h1 {
      font-size: 2em;
      /* 2*16 = 32 */
    }

    h2 {
      font-size: 1.5em;
      /* 1.5*16 = 24 */
    }

    h3 {
      font-size: 1.17em;
      /* 1.17*16 = 18.72 */
    }

    h4 {
      font-size: 1em;
      /* 1*16 = 16 */
    }

    h5 {
      font-size: 0.83em;
      /* 0.83*16 = 13.28 */
    }

    h6 {
      font-size: 0.75em;
      /* 0.75*16 = 12 */
    }

    h1 {
      margin: 2.42424rem 0 1.454544rem;
    }

    h2 {
      margin: 2.0202rem 0 1.21212rem;
    }

    h3 {
      margin: 1.61616rem 0 1rem;
    }

    h4 {
      margin: 1.21212rem 0 1;
    }

    h5 {
      margin: 0.80808rem 0;
    }

    h6 {
      margin: 0.70707rem 0;
    }

    p {
      margin: auto auto 1.5rem;
    }

    small {
      font-size: 65%;
    }

    input,
    abbr,
    acronym,
    blockquote,
    code,
    kbd,
    q,
    samp,
    var {
      -webkit-hyphens: none;
      -ms-hyphens: none;
      hyphens: none;
    }

    pre {
      white-space: pre;
    }

    pre code {
      white-space: -moz-pre-wrap;
      white-space: pre-wrap;
    }

    code {
      white-space: pre;
      font-family: SF Mono, Consolas, Dejavu Sans Mono, Menlo, monospace;
    }

    abbr {
      -webkit-font-variant: small-caps;
      -moz-font-variant: small-caps;
      -ms-font-variant: small-caps;
      font-variant: small-caps;
      font-weight: 600;
      text-transform: lowercase;
      color: gray;
    }

    abbr[title]:hover {
      cursor: help;
    }

    /* FROM http://purecss.io/layouts/side-menu/  adapted to remove pure classes*/

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      color: #444;
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: auto;
    }

    code,
    pre {
      background-color: #f5f5f5;
      color: #444;
      border-radius: 2px;
      text-shadow: 0px 1px 0px white;
      box-shadow: 0 1px 1px rgba(0, 0, 0, 0.15);
    }

    pre code {
      border: none;
      box-shadow: none;
    }

    pre {
      padding: 0.5em;
    }

    code {
      display: inline-block;
      padding: 0 0.5em;
      line-height: 1.4;
      font-size: 0.9em;
    }

    table {
      border-spacing: 0;
      margin-bottom: 1.5rem;
    }

    table th,
    table td {
      padding: 0.3em 0.7em;
    }

    table th {
      background-color: #f4f4f4;
      border-bottom: 2px solid #444;
    }

    table td {
      border: 1px solid #f5f5f5;
    }

    /* Add transition to containers so they can push in and out. */

    #layout,
    #menu,
    .menu-link {
      -webkit-transition: all 0.2s ease-out;
      -moz-transition: all 0.2s ease-out;
      -ms-transition: all 0.2s ease-out;
      -o-transition: all 0.2s ease-out;
      transition: all 0.2s ease-out;
    }

    /* This is the parent `<div>` that contains the menu and the content area. */

    #layout {
      position: relative;
      padding-left: 0;
    }

    #layout.active #menu {
      left: 300px;
      width: 300px;
    }

    #layout.active .menu-link {
      left: 300px;
    }

    /* The content `<div>` is where all your content goes. */

    .content {
      margin: 50px auto;
      padding: 0;
      max-width: 60%;
      line-height: 1.6em;
    }

    /*
    The `#menu` `<div>` is the parent `<div>` that contains the menu that
    appears on the left side of the page.
    */

    #menu {
      margin-left: -300px;
      /* "#menu" width */
      width: 300px;
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      z-index: 1000;
      /* so the menu or its navicon stays above all content */
      background: #f4f4f4;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      font-size: 0.9em;
    }

    a,
    a * {
      text-decoration: none;
      color: #2483cc;
    }

    a:visited {
      text-decoration: none;
      color: #2483cc;
    }

    /* All anchors inside the menu should be styled like this. */

    #menu a {
      display: inline-block;
      padding: 0.1em 0.5em;
    }

    #menu a:first-letter {
      text-transform: capitalize;
    }

    #menu ul {
      list-style-type: none;
      padding: 0;
      margin: 0em 0.5em;
    }

    #menu ul ul {
      margin-top: 0em;
      margin-left: 0.6em;
      border-left: 1px dotted rgb(64, 64, 64);
	  padding-left: 0.5em;
    }

    /* Change color of the anchor links on hover/focus. */

    #menu li a:hover,
    #menu li a:focus {
      background: rgba(255, 255, 255, 0.4);
    }

    /* This styles the selected menu item `<li>`. */

    #menu li a.active {
      background: rgba(0, 0, 0, 0.05);
    }

    /* This styles a link within a selected menu item `<li>`. */

    #menu li a.active {
      color: #222;
    }

    /* This styles the menu heading. */

    #menu li.heading {
      font-size: 0.9em;
      /*text-transform: uppercase;*/
      color: #000;
    }

    #menu li.heading>* {
      padding: 0.1em 0.5em;
      display: block;
    }

    #menu li.heading a {
      color: #0c68af;
    }

    /* -- Dynamic Button For Responsive Menu -------------------------------------*/

    /*
    `.menu-link` represents the responsive menu toggle that shows/hides on
    small screens.
    */

    .menu-link {
      position: fixed;
      display: block;
      /* show this only on small screens */
      top: 0;
      left: 0;
      /* "#menu width" */
      background: #f4f4f4;
      font-size: 10px;
      /* change this value to increase/decrease button size */
      z-index: 10;
      width: 2em;
      height: auto;
      padding: 1.6em 1.2em;
      border-radius: 0 2px 2px 0;
    }

    .menu-link:hover {
      background: /* #f4f4f4 * 0.8 */
      #eee;
    }

    .menu-link span {
      position: relative;
      display: block;
    }

    .menu-link span,
    .menu-link span:before,
    .menu-link span:after {
      background-color: #555;
      width: 100%;
      height: 0.2em;
      border-radius: 1em;
    }

    .menu-link span:before,
    .menu-link span:after {
      position: absolute;
      margin-top: -0.6em;
      content: " ";
    }

    .menu-link span:after {
      margin-top: 0.6em;
    }

    @media (max-width: 1300px) {       
	  .content.active {
		  margin-left: 310px;
	  }
    }
	
	@media (max-width: 800px) {
		.content {
		  max-width: 98%;
	  }
	}

	#menu li span {
		padding: 0.1em 0.5em;
	}
	
	li.collapsible {
		cursor: pointer;
		font-weight:bold;
	}
	
	li.collapsible span.collapser:before {
		display:inline-block;
		width:0.5em;
	}
	
	li.collapsible span.collapser:before {
		content: "-";
	}
	
	li.collapsed span.collapser:before {
		content: "+";
	}
	
	li.collapsed + ul {
		display:none;
	}

      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8">
  <!--script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script-->
  <script src="..\..\..\scripts\mathjax\es5\tex-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>

<body>
  <div id="layout" class="active">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link active">
      <!-- Hamburger icon -->
      <span></span>
    </a>
    <nav id="menu" class="active">
<ul>
<li class="heading"><a href="..\..\..\index.html">Home</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\index.html">Getting Started</a></li>
<ul>
<li class="heading"><a href="..\..\..\01-Getting_Started\01-SDK_Overview.html">SDK Overview</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\02-FAQ.html">FAQ</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\03-Roadmap.html">Roadmap</a></li>
<li class="heading"><span>Samples</span></li>
<ul>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\Aircraft\index.html">Aircraft</a></li>
<ul>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\Aircraft\GaugeAircraft\index.html">GaugeAircraft</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\Aircraft\GdiplusAircraft\index.html">GdiplusAircraft</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\Aircraft\MouseAircraft\index.html">MouseAircraft</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\Aircraft\SimpleAircraft\index.html">SimpleAircraft</a></li>
</ul>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\SimpleAerial\index.html">SimpleAerial</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\SimpleAirport\index.html">SimpleAirport</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\SimpleBiomes\index.html">SimpleBiomes</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\SimpleNavData\index.html">SimpleNavData</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\SimpleScenery\index.html">SimpleScenery</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\SimvarWatcher\index.html">SimvarWatcher</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\Samples\WwiseSampleProject\index.html">WwiseSampleProject</a></li>
</ul>
<li class="heading"><span>Tutorials</span></li>
<ul>
<li class="heading"><a href="..\..\..\01-Getting_Started\Tutorials\01-Placing_An_Add-on_Airport\index.html">Placing An Add-on Airport</a></li>
<li class="heading"><a href="..\..\..\01-Getting_Started\Tutorials\02-Flight_model_definition\index.html">Flight model definition</a></li>
</ul>
</ul>
<li class="heading"><span>Asset Creation</span></li>
<ul>
<li class="heading"><a href="..\..\..\02-Asset_Creation\3D_Models\index.html">3D Models</a></li>
<ul>
<li class="heading"><span>Modeling Practices</span></li>
<ul>
<li class="heading"><a href="..\..\..\02-Asset_Creation\3D_Models\Modeling_Practices\01-Aircraft_Modeling.html">Aircraft Modeling</a></li>
<li class="heading"><a href="..\..\..\02-Asset_Creation\3D_Models\Modeling_Practices\02-Levels_of_Detail.html">Levels of Detail</a></li>
<li class="heading"><a href="..\..\..\02-Asset_Creation\3D_Models\Modeling_Practices\03-Aircraft_Texture_Mapping.html">Aircraft Texture Mapping</a></li>
<li class="heading"><a href="..\..\..\02-Asset_Creation\3D_Models\Modeling_Practices\04-Collisions.html">Collisions</a></li>
</ul>
</ul>
<li class="heading"><a href="..\..\..\02-Asset_Creation\Lighting_Model\index.html">Lighting Model</a></li>
<li class="heading"><a href="..\..\..\02-Asset_Creation\Sounds\index.html">Sounds</a></li>
<ul>
<li class="heading"><a href="..\..\..\02-Asset_Creation\Sounds\01-Master_Mixer_Hierarchy.html">Master Mixer Hierarchy</a></li>
<li class="heading"><a href="..\..\..\02-Asset_Creation\Sounds\02-Shared_Game_Parameters.html">Shared Game Parameters</a></li>
<li class="heading"><a href="..\..\..\02-Asset_Creation\Sounds\03-Shared_States_and_Switches.html">Shared States and Switches</a></li>
<li class="heading"><a href="..\..\..\02-Asset_Creation\Sounds\04-Shared_Attenuation_Shareset.html">Shared Attenuation Shareset</a></li>
<li class="heading"><a href="..\..\..\02-Asset_Creation\Sounds\05-Mix_your_Aircraft.html">Mix your Aircraft</a></li>
</ul>
<li class="heading"><a href="..\..\..\02-Asset_Creation\Textures\index.html">Textures</a></li>
<li class="heading"><a href="..\..\..\02-Asset_Creation\glTF_Materials.html">glTF Materials</a></li>
</ul>
<li class="heading"><span>Content Configuration</span></li>
<ul>
<li class="heading"><a href="..\..\Cameras\index.html">Cameras</a></li>
<ul>
<li class="heading"><a href="..\..\Cameras\Camera_Configuration.html">Camera Configuration</a></li>
<li class="heading"><a href="..\..\Cameras\RTC\index.html">RTC</a></li>
<ul>
<li class="heading"><a href="..\..\Cameras\RTC\Examples.html">Examples</a></li>
<li class="heading"><a href="..\..\Cameras\RTC\Using_RTCs.html">Using RTCs</a></li>
<li class="heading"><a href="..\..\Cameras\RTC\XML_Definition.html">XML Definition</a></li>
</ul>
<li class="heading"><a href="..\..\Cameras\Wow-effect.html">Wow-effect</a></li>
</ul>
<li class="heading"><a href="..\..\Environment\index.html">Environment</a></li>
<ul>
<li class="heading"><a href="..\..\Environment\Airports_And_Facilities\index.html">Airports And Facilities</a></li>
<ul>
<li class="heading"><a href="..\..\Environment\Airports_And_Facilities\Airports.html">Airports</a></li>
<li class="heading"><a href="..\..\Environment\Airports_And_Facilities\Jetways.html">Jetways</a></li>
</ul>
<li class="heading"><a href="..\..\Environment\File_Formats\index.html">File Formats</a></li>
<ul>
<li class="heading"><a href="..\..\Environment\File_Formats\BGL.html">BGL</a></li>
<li class="heading"><a href="..\..\Environment\File_Formats\CGL.html">CGL</a></li>
</ul>
<li class="heading"><a href="..\..\Environment\Living_World\index.html">Living World</a></li>
<ul>
<li class="heading"><a href="..\..\Environment\Living_World\AirportServices\index.html">AirportServices</a></li>
<ul>
<li class="heading"><a href="..\..\Environment\Living_World\AirportServices\XMLdefs.html">XMLdefs</a></li>
<li class="heading"><a href="..\..\Environment\Living_World\AirportServices\examples.html">examples</a></li>
</ul>
<li class="heading"><a href="..\..\Environment\Living_World\LivingWorld_Config\index.html">LivingWorld Config</a></li>
<ul>
<li class="heading"><a href="..\..\Environment\Living_World\LivingWorld_Config\XMLdefs.html">XMLdefs</a></li>
<li class="heading"><a href="..\..\Environment\Living_World\LivingWorld_Config\examples.html">examples</a></li>
</ul>
<li class="heading"><a href="..\..\Environment\Living_World\Traffic\index.html">Traffic</a></li>
</ul>
<li class="heading"><a href="..\..\Environment\Scenery_Objects\index.html">Scenery Objects</a></li>
<ul>
<li class="heading"><a href="..\..\Environment\Scenery_Objects\Effects.html">Effects</a></li>
</ul>
<li class="heading"><a href="..\..\Environment\Terrain\index.html">Terrain</a></li>
<ul>
<li class="heading"><a href="..\..\Environment\Terrain\Aerial_Imagery\index.html">Aerial Imagery</a></li>
<li class="heading"><a href="..\..\Environment\Terrain\DEM\index.html">DEM</a></li>
<li class="heading"><a href="..\..\Environment\Terrain\Vector_Shapes\index.html">Vector Shapes</a></li>
</ul>
<li class="heading"><a href="..\..\Environment\Vegetation\index.html">Vegetation</a></li>
<li class="heading"><a href="..\..\Environment\Weather\index.html">Weather</a></li>
<li class="heading"><a href="..\..\Environment\World_Positioning_Systems\index.html">World Positioning Systems</a></li>
<ul>
<li class="heading"><a href="..\..\Environment\World_Positioning_Systems\Bing_Maps_Tile_System.html">Bing Maps Tile System</a></li>
<li class="heading"><a href="..\..\Environment\World_Positioning_Systems\Lat_Long_Alt.html">Lat Long Alt</a></li>
<li class="heading"><a href="..\..\Environment\World_Positioning_Systems\QMID.html">QMID</a></li>
</ul>
</ul>
<li class="heading"><a href="..\..\Flights_And_Missions\index.html">Flights And Missions</a></li>
<ul>
<li class="heading"><a href="..\..\Flights_And_Missions\Flight_Files.html">Flight Files</a></li>
</ul>
<li class="heading"><a href="..\..\Localization\index.html">Localization</a></li>
<li class="heading"><span>SimObjects</span></li>
<ul>
<li class="heading"><a href=".\index.html">Aircraft</a></li>
<ul>
<li class="heading"><a href=".\Aircraft_Configuration\index.html">Aircraft Configuration</a></li>
<ul>
<li class="heading"><a href=".\Aircraft_Configuration\00-General.html">General</a></li>
<li class="heading"><a href=".\Aircraft_Configuration\AI.html">AI</a></li>
<li class="heading"><a href=".\Aircraft_Configuration\Cameras.html">Cameras</a></li>
<li class="heading"><a href=".\Aircraft_Configuration\Cockpit.html">Cockpit</a></li>
<li class="heading"><a href=".\Aircraft_Configuration\Engines.html">Engines</a></li>
<li class="heading"><a href=".\Aircraft_Configuration\Flight_Model.html">Flight Model</a></li>
<li class="heading"><a href=".\Aircraft_Configuration\Gameplay.html">Gameplay</a></li>
<li class="heading"><a href=".\Aircraft_Configuration\InteractivePoints.html">InteractivePoints</a></li>
<li class="heading"><a href=".\Aircraft_Configuration\Systems_Configuration_File.html">Systems Configuration File</a></li>
<li class="heading"><a href=".\Aircraft_Configuration\Target_Performances_Configuration_File.html">Target Performances Configuration File</a></li>
</ul>
<li class="heading"><a href=".\Flight_Model.html">Flight Model</a></li>
</ul>
<li class="heading"><a href="..\01-Other_SimObjects\index.html">Other SimObjects</a></li>
<ul>
<li class="heading"><a href="..\01-Other_SimObjects\Animals.html">Animals</a></li>
<li class="heading"><a href="..\01-Other_SimObjects\Boats.html">Boats</a></li>
<li class="heading"><a href="..\01-Other_SimObjects\GroundVehicles\index.html">GroundVehicles</a></li>
<ul>
<li class="heading"><a href="..\01-Other_SimObjects\GroundVehicles\BaggageCart.html">BaggageCart</a></li>
<li class="heading"><a href="..\01-Other_SimObjects\GroundVehicles\BaggageLoader.html">BaggageLoader</a></li>
<li class="heading"><a href="..\01-Other_SimObjects\GroundVehicles\BoardingRamp.html">BoardingRamp</a></li>
<li class="heading"><a href="..\01-Other_SimObjects\GroundVehicles\CateringTruck.html">CateringTruck</a></li>
<li class="heading"><a href="..\01-Other_SimObjects\GroundVehicles\FuelTruck.html">FuelTruck</a></li>
<li class="heading"><a href="..\01-Other_SimObjects\GroundVehicles\GroundPowerUnit.html">GroundPowerUnit</a></li>
<li class="heading"><a href="..\01-Other_SimObjects\GroundVehicles\Pushback.html">Pushback</a></li>
</ul>
<li class="heading"><a href="..\01-Other_SimObjects\Humans.html">Humans</a></li>
<li class="heading"><a href="..\01-Other_SimObjects\SimObject_Configuration.html">SimObject Configuration</a></li>
<li class="heading"><a href="..\01-Other_SimObjects\StaticObjects.html">StaticObjects</a></li>
</ul>
<li class="heading"><a href="..\Checklists\index.html">Checklists</a></li>
<ul>
<li class="heading"><a href="..\Checklists\01-Examples.html">Examples</a></li>
<li class="heading"><a href="..\Checklists\02-XML_Definition.html">XML Definition</a></li>
</ul>
<li class="heading"><a href="..\Instruments\index.html">Instruments</a></li>
<ul>
<li class="heading"><a href="..\Instruments\3D_Instruments\index.html">3D Instruments</a></li>
<li class="heading"><a href="..\Instruments\C_Gauges\index.html">C Gauges</a></li>
<ul>
<li class="heading"><span>Graphics</span></li>
<ul>
<li class="heading"><a href="..\Instruments\C_Gauges\Graphics\GDI_Plus.html">GDI Plus</a></li>
</ul>
</ul>
<li class="heading"><a href="..\Instruments\HTML_Gauges\index.html">HTML Gauges</a></li>
<li class="heading"><a href="..\Instruments\Panels.html">Panels</a></li>
<li class="heading"><a href="..\Instruments\XML_Gauges\index.html">XML Gauges</a></li>
</ul>
<li class="heading"><a href="..\Models\index.html">Models</a></li>
<ul>
<li class="heading"><a href="..\Models\AnimGraph.html">AnimGraph</a></li>
<li class="heading"><a href="..\Models\Levels_of_Detail_(LODs).html">Levels of Detail (LODs)</a></li>
<li class="heading"><a href="..\Models\Model_Behaviors\index.html">Model Behaviors</a></li>
<ul>
<li class="heading"><a href="..\Models\Model_Behaviors\XML_Definition.html">XML Definition</a></li>
</ul>
</ul>
<li class="heading"><a href="..\Sounds\index.html">Sounds</a></li>
<ul>
<li class="heading"><a href="..\Sounds\backwards_compatibility.html">backwards compatibility</a></li>
<li class="heading"><a href="..\Sounds\sound_categories.html">sound categories</a></li>
<li class="heading"><a href="..\Sounds\xml_definition.html">xml definition</a></li>
<li class="heading"><a href="..\Sounds\xml_wavedata.html">xml wavedata</a></li>
</ul>
<li class="heading"><a href="..\Textures\index.html">Textures</a></li>
</ul>
<li class="heading"><a href="..\..\UI\index.html">UI</a></li>
<li class="heading"><a href="..\..\Variable_Lists\index.html">Variable Lists</a></li>
<ul>
<li class="heading"><a href="..\..\Variable_Lists\Event_IDs.html">Event IDs</a></li>
<li class="heading"><a href="..\..\Variable_Lists\Misc_Enums.html">Misc Enums</a></li>
<li class="heading"><a href="..\..\Variable_Lists\Simulation_Variables.html">Simulation Variables</a></li>
</ul>
<li class="heading"><a href="..\..\Visual_Effects\index.html">Visual Effects</a></li>
<ul>
<li class="heading"><a href="..\..\Visual_Effects\visual_fx_file.html">visual fx file</a></li>
</ul>
</ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\index.html">Developer Tools</a></li>
<ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\00-Developer_Mode\index.html">Developer Mode</a></li>
<li class="heading"><span>3DS Max Tools</span></li>
<ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\3DS_Max_Tools\FlightSim_Lights.html">FlightSim Lights</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\3DS_Max_Tools\FlightSim_Material.html">FlightSim Material</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\3DS_Max_Tools\FlightSim_multiExporter.html">FlightSim multiExporter</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\3DS_Max_Tools\FlightSim_versionDifferences.html">FlightSim versionDifferences</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\3DS_Max_Tools\glTF_Exporter.html">glTF Exporter</a></li>
</ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Aircraft_Editor\index.html">Aircraft Editor</a></li>
<ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Aircraft_Editor\Debug_Windows.html">Debug Windows</a></li>
</ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Command_Line_Interface.html">Command Line Interface</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Launcher_Tool\index.html">Launcher Tool</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Material_Editor\index.html">Material Editor</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Mission_Editor\index.html">Mission Editor</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Package_Tool\index.html">Package Tool</a></li>
<ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Package_Tool\Concepts.html">Concepts</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Package_Tool\XMLReference.html">XMLReference</a></li>
</ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Project_editor\index.html">Project editor</a></li>
<ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Project_editor\Content_Manager_Data.html">Content Manager Data</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Project_editor\Export_Window.html">Export Window</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Project_editor\Marketplace_Data.html">Marketplace Data</a></li>
</ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\Scenery_Editor\index.html">Scenery Editor</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\SimConnect\index.html">SimConnect</a></li>
<ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\SimConnect\SimConnect_Reference.html">SimConnect Reference</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\SimConnect\SimConnect_Status_of_Functions.html">SimConnect Status of Functions</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\SimConnect\SimConnect_Status_of_Input_Events.html">SimConnect Status of Input Events</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\SimConnect\SimConnect_Status_of_SimEvents.html">SimConnect Status of SimEvents</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\SimConnect\SimConnect_Status_of_Simulation_Variables.html">SimConnect Status of Simulation Variables</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\SimConnect\SimConnect_Status_of_System_Events.html">SimConnect Status of System Events</a></li>
</ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\WebAssembly\index.html">WebAssembly</a></li>
<ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\WebAssembly\01-Platform_Toolset.html">Platform Toolset</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\WebAssembly\02-Gauge_API.html">Gauge API</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\WebAssembly\Graphics\index.html">Graphics</a></li>
<ul>
<li class="heading"><a href="..\..\..\04-Developer_Tools\WebAssembly\Graphics\GDI_Plus.html">GDI Plus</a></li>
<li class="heading"><a href="..\..\..\04-Developer_Tools\WebAssembly\Graphics\Low_Level_API.html">Low Level API</a></li>
</ul>
</ul>
</ul>
<li class="heading"><span>Scripting Languages</span></li>
<ul>
<li class="heading"><a href="..\..\..\05-Scripting_Languages\CFG.html">CFG</a></li>
<li class="heading"><a href="..\..\..\05-Scripting_Languages\Reverse_Polish_Notation.html">Reverse Polish Notation</a></li>
</ul>
</ul>
    </nav>
    <article id="main" class="content active">
      <h1 id="flight-model">Flight Model</h1>
      <p>This document is a very technical description of the flight model used in Microsoft Flight Simulator. All parameters for it should be defined in the <a href="Aircraft_Configuration/index.html">Aircraft Configuration File</a>. For documentation on the legacy AIR File Format, please look at the <a href="https://docs.microsoft.com/en-us/previous-versions/microsoft-esp/cc526961">ESP Flight Models documentation</a>.</p>
      <!-- START doctoc generated TOC please keep comment here to allow auto update -->
      <!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
      <ul>
      <li><a href="#what-is-a-flight-dynamics-model">What is a Flight Dynamics Model?</a></li>
      <li><a href="#aircraft-description">Aircraft description</a>
      <ul>
      <li><a href="#wing-description">Wing description</a></li>
      <li><a href="#control-description">Control description</a></li>
      <li><a href="#aircraft-mechanical-description">Aircraft mechanical description</a></li>
      </ul></li>
      <li><a href="#referential-frames-and-conventions">Referential frames and conventions</a>
      <ul>
      <li><a href="#canonical-inertial-frame">Canonical inertial frame</a></li>
      <li><a href="#aircraft-body-frame">Aircraft body frame</a></li>
      <li><a href="#reference-datum-frame">Reference datum frame</a></li>
      </ul></li>
      <li><a href="#fundamental-equations">Fundamental equations</a>
      <ul>
      <li><a href="#fundamental-equations-in-inertial-frame">Fundamental equations in inertial frame</a></li>
      <li><a href="#rewriting-in-the-aircraft-body-frame">Rewriting in the aircraft body frame</a></li>
      <li><a href="#linear-perturbations-theory">Linear perturbations theory</a></li>
      <li><a href="#numerical-integration-at-each-time-step">Numerical integration at each time step</a></li>
      </ul></li>
      <li><a href="#forces-and-kinetic-moments-computations">Forces and kinetic moments computations</a>
      <ul>
      <li><a href="#aerodynamic-forces">Aerodynamic forces</a></li>
      </ul></li>
      <li><a href="#microsoft-flight-simulator-new-flight-model">Microsoft Flight Simulator new flight model</a>
      <ul>
      <li><a href="#surface-elements-definition">Surface elements definition</a></li>
      <li><a href="#normalization-algorithm">Normalization algorithm</a></li>
      <li><a href="#complex-physical-phenomena-modelization">Complex physical phenomena modelization</a></li>
      </ul></li>
      </ul>
      <!-- END doctoc generated TOC please keep comment here to allow auto update -->
      <h2 id="what-is-a-flight-dynamics-model">What is a Flight Dynamics Model?</h2>
      <p>The problem of simulating a flight can be stated as follows: knowing the current dynamic configuration of my aircraft (position, orientation, and translation and rotational velocities), and considering a new user input to pilot the aircraft controls (ailerons, rudders, elevators, spoilers…), what will be the next configuration of my aircraft?</p>
      <p>Mathematically speaking, this problem can be expressed under the form of a first-order system of Ordinary Differential Equations of unknown <span class="math inline">\(\boldsymbol{X}_{\textrm{state}}\)</span>:</p>
      <p><span class="math display">\[\frac{\mathrm{d} \boldsymbol{X}_{\textrm{state}} }{\mathrm{d}t} (t)= H\left(\boldsymbol{X}_{\textrm{state}}(t), \boldsymbol{\delta}_{\textrm{controls}}(t)\right)\]</span></p>
      <p>where</p>
      <ul>
      <li><span class="math inline">\(\boldsymbol{X}_{\textrm{state}}\)</span> is the vector of all primary 6-DOF aircraft state variables which gives, at each time <span class="math inline">\(t\)</span>, the exact dynamic configuration of the aircraft:</li>
      </ul>
      <p><span class="math display">\[
      \begin{array}{lll}
      \boldsymbol{X}_{\textrm{state}} &amp;= \left(
          \begin{array}{l}
          x_G\\
          y_G\\
          z_G\\
          \theta_x\\
          \theta_y\\
          \theta_z\\
          v_{x,G}\\
          v_{y,G}\\
          v_{z,G}\\
              q\\
              r\\
              p
          \end{array}
          \right)
          &amp;
          \begin{array}{ll}
          \left.
          \begin{array}{l}
          \\
          \\
          \\
          \end{array}
          \right\} &amp; \textrm{position}\\
          \left.
          \begin{array}{l}
          \\
          \\
          \\
          \end{array}
          \right\} &amp; \textrm{orientation or attitude}\\
          \left.
          \begin{array}{l}
          \\
          \\
          \\
          \end{array}
          \right\} &amp; \textrm{translational velocity}\\
          \left.
          \begin{array}{l}
          \\
          \\
          \\
          \end{array}
          \right\} &amp; \textrm{rotational velocity}
          \end{array}
      \end{array}
      \]</span></p>
      <ul>
      <li><span class="math inline">\(\boldsymbol{\delta}_{\textrm{controls}}\)</span> is the input controls vector that gives, at each time <span class="math inline">\(t\)</span>, the state increment of the aircraft controls (rudder, ailerons, spoilers, elevators…) as entered by user:</li>
      </ul>
      <p><span class="math display">\[
      \begin{array}{lll}
      \boldsymbol{\delta}_{\textrm{controls}} &amp;
      = \left(
          \begin{array}{l}
          \delta_{a} \\
          \delta_{e} \\
          \delta_{r} \\
          \delta_{s}\\
          \end{array}
          \right) 
          &amp; 
          \begin{array}{l}
          \textrm{ailerons}\\
          \textrm{elevators}\\
          \textrm{rudder}\\
          \textrm{spoilers}
          \end{array}
      \end{array}
      \]</span></p>
      <ul>
      <li><span class="math inline">\(H\)</span> is a complicated vectorial function, generally non-linear, describing how the aircraft responds to user inputs according to the fundamental equations of solid dynamics (6 DOF)</li>
      </ul>
      <p><img src="./images/FlightModelLogic.png"></p>
      <p>In the following, we will go into the details of each aspect of this equation, notably what this <span class="math inline">\(H\)</span> function exactly is, and we will explain how the equation is solved numerically to update the aircraft state.</p>
      <h2 id="aircraft-description">Aircraft description</h2>
      <h3 id="wing-description">Wing description</h3>
      <h4 id="geometric-description">Geometric description</h4>
      <p>The projection of the wing of the plane on the <span class="math inline">\(x-z\)</span> plane is called the wing planform. A typical planform is sketched below:</p>
      <p><img src="./images/TrapezoidalApproximation.png"></p>
      <ul>
      <li><span class="math inline">\(S\)</span> is the wing area, the area of the planform</li>
      </ul>
      <p><span class="math display">\[S = \int_{0}^{\frac{b}{2}}{c(x)\mathrm{d}x}\]</span></p>
      <ul>
      <li><span class="math inline">\(b\)</span> is the wing span, the maximum lateral extent of the planform</li>
      <li><span class="math inline">\(c_{tip}\)</span> is the chord at the tip</li>
      <li><span class="math inline">\(c_{root}\)</span> is the chord at the root</li>
      <li><span class="math inline">\(\lambda =\frac{c_{tip}}{c_{root}}\)</span> is the tapper ratio</li>
      <li><span class="math inline">\(AR=\frac{b^2}{S}\)</span> is the aspect ratio of the planform</li>
      <li><span class="math inline">\(\Lambda_n\)</span> is the sweep angle of any constant-chord fraction i.e the angle formed by <span class="math inline">\(\boldsymbol{e}_x\)</span> and the line linking all the points located at distance <span class="math inline">\((1/n)\,c(x)\)</span> from the leading edge. For instance, <span class="math inline">\(\Lambda_0\)</span> corresponds to the angle between the leading edge and lateral direction <span class="math inline">\(\boldsymbol{e}_x\)</span>.</li>
      <li><span class="math inline">\(\Gamma\)</span> is the dihedral angle of the wing</li>
      </ul>
      <p>A <em>wing section</em>, or <em>airfoil</em>, is simply a cut through the lifting surface in a plane of constant <span class="math inline">\(x\)</span>.</p>
      <p><img src="./images/AirfoilSection.png"></p>
      <p>Several quantities are associated with a sectional airfoil: * <span class="math inline">\(c=c(x)\)</span> is the local section chord size * <span class="math inline">\(\epsilon = \epsilon(x)\)</span> is the section angular twist with respect to the root section * <span class="math inline">\(\alpha = \alpha(x)\)</span> is the deviation of the angle of attack for section x with respect to the angle of attack at wing root section, which is THE angle of attack taken as reference for the simulation</p>
      <p>From these purely geometric data, we can compute several data of major interest in aerodynamics theory</p>
      <ul>
      <li><span class="math inline">\(\bar{c}\)</span> the mean aerodynamic chord (MAC) of the wing:</li>
      </ul>
      <p><span class="math display">\[\bar{c} = \frac{2}{S}\int_{0}^{\frac{b}{2}}{c^2(x)\mathrm{d}x}\]</span></p>
      <p>The MAC can be considered a two-dimensional representation of the whole wing. The pressure distribution over the entire wing can be reduced to a single lift force on and a moment around the aerodynamic center of the MAC (that we will define just below). Therefore, not only the length but also the position of MAC is often important. In particular, the position of center of gravity (CG) of an aircraft is usually measured relative to the MAC, as the percentage of the distance from the leading edge of MAC to CG with respect to MAC itself. In the same manner as we have reduced all the chords <span class="math inline">\(c(x)\)</span> to a single MAC chord <span class="math inline">\(\bar{c}\)</span>, we can reduce all the positions of the points <span class="math inline">\(z_n(x)\)</span> located at a fraction <span class="math inline">\(n\)</span> from the leading edge of the local chord <span class="math inline">\(c(x)\)</span> to a single averaged position <span class="math inline">\(\bar{z}_n\)</span></p>
      <ul>
      <li><span class="math inline">\(\Delta \bar{z_{n}} = z_{\textrm{wing apex}} - \bar{z_{n}}\)</span> the longitudinal location of this averaged chord-fraction point on the MAC with respect to wing apex is then:</li>
      </ul>
      <p><span class="math display">\[
      \Delta \bar{z}_{n} = \frac{2}{S}\int_0^{\frac{b}{2}}{\Delta z_n(x)\,c(x)\mathrm{d}x}
      \]</span></p>
      <p>All these quantities can be analytically computed for a trapezoidal tappered swept wing like the one depicted in Figure . In this specific case, we get:</p>
      <p><span class="math display">\[
      S = b\, c_{root}\frac{1+\lambda}{2}
      \]</span></p>
      <p>The sweep angle of any constant chord fraction line can be related to that of the leading edge sweep angle by:</p>
      <p><span class="math display">\[
      AR\, \textrm{tan}\Lambda_n = AR\, \textrm{tan}\Lambda_0 -4 n \frac{1-\lambda}{1+\lambda}
      \]</span></p>
      <p>The equivalent planform MAC is:</p>
      <p><span class="math display">\[
      \bar{c} = \frac{2\left(1+\lambda+\lambda^2\right)}{3\left(1+\lambda\right)} c_{root}\,,
      \]</span></p>
      <p>The location of any chord-fraction <span class="math inline">\(n\)</span> point on the MAC relative to the wing apex is:</p>
      <p><span class="math display">\[
      \Delta \bar{z}_{n} = \bar{c}\left(n+\frac{(1+\lambda)\,(1+2\lambda)}{8\,(1+\lambda+\lambda^2)}\, \textrm{AR} \, \textrm{tan}\Lambda_0\right)
      = n \bar{c} + \frac{b}{6}\left(\frac{1+2\lambda}{1+\lambda}\right)\textrm{tan}\Lambda_0
      \]</span></p>
      <p>For instance, the longitudinal position of the leading edge of the equivalent planform, called reference chord in FSX, in body coordinate system centered at VMO is:</p>
      <p><span class="math display">\[
      z_{\textrm{ref chord}} = z_{\textrm{wing apex}} - \Delta \bar{z}_{0} = z_{\textrm{wing apex}}  - \frac{b}{6}\left(\frac{1+2\lambda}{1+\lambda}\right)\textrm{tan}\Lambda_0
      \]</span></p>
      <p>The placing of MAC leading edge (reference chord) to the correct position along the airplane body is important for a correct CG indication in gauges However, it does not affect flight dynamics. This means that the only wing geometrical parameters influencing the simulation are: * <span class="math inline">\(S\)</span> * <span class="math inline">\(b\)</span> * <span class="math inline">\(c_{root}\)</span> * wing_incidence (influence on AoA on lift calculation)</p>
      <p>From them the code computes: * <span class="math inline">\(c_{tip} = \frac{2S}{b} -c_{root}\)</span> * <span class="math inline">\(\lambda = \frac{c_{tip}}{c_{root}}\)</span> * <span class="math inline">\(\bar{c} = \frac{2\left(1+\lambda+\lambda^2\right)}{3\left(1+\lambda\right)} c_{root}\,,\)</span> * <span class="math inline">\(AR = \frac{b^2}{S}\)</span></p>
      <p>The following geometrical parameters can be prescribed but are used only for debug or gauges indications: * wing dihedral * wing_pos_apex_vert, wing_pos_apex_lon * wing_pos_refchord, wing_cg_refchord * wing sweep</p>
      <p>Used by Seb * wing_twist * wing_dihedral</p>
      <h4 id="aerodynamic-description">Aerodynamic description</h4>
      <ul>
      <li><p>wing_oswald is not used ##### Aerodynamic coefficients</p></li>
      <li><p><span class="math inline">\(c_{\ell}\)</span></p></li>
      </ul>
      <p>The lift, drag and pitching moments adimensional coefficients of the wing are defined as:</p>
      <ul>
      <li>Lift coefficient <span class="math inline">\(C_L = \frac{L}{QS}\)</span></li>
      <li>Drag coefficient <span class="math inline">\(C_D = \frac{D}{QS}\)</span></li>
      <li>Pitching moment coefficient <span class="math inline">\(C_m = \frac{M}{QS\bar{c}}\)</span>, by convention it is generally computed with respect to quarter-chord point of the airfoil (i.e aerodynamic center)</li>
      </ul>
      <p>where <span class="math inline">\(Q = \frac{1}{2}\rho u_z^2\)</span> is the dynamic pressure and <span class="math inline">\(L\)</span>, <span class="math inline">\(D\)</span> and <span class="math inline">\(M\)</span> are respectively the lift force, the drag force and the pitching moment</p>
      <h5 id="pressure-center">Pressure center</h5>
      <p>The pressure center <span class="math inline">\(P_{pc}(x)\)</span> is the physical point of application of the resulting aerodynamic forces, generally taking into account only the lift force. Its position depends on the way the local pressure forces are located around the airfoil section. It can be evaluated from the pitch moment and the lift. We note <span class="math inline">\(z_{pc}(x)\)</span> the longitudinal position of <span class="math inline">\(P_{pc}\)</span> with respect to the longitudinal position of the point <span class="math inline">\(P\)</span> at which the pitching moment has been evaluated:</p>
      <p><span class="math display">\[
      \frac{z_{pc}(x)}{c(x)} = -\frac{c_{m,P}(x)}{c_{\ell}}(x)
      \]</span></p>
      <p>This point <em>moves</em> depending on the angle of attack. When the angle of attack is zero, it is located about 3/4 of the chord from the leading edge, and moves forward as the angle of attack increases, until max 30% the the chord from the leading edge.</p>
      <h5 id="aerodynamic-center">Aerodynamic center</h5>
      <p>The <em>section aerodynamic center</em> <span class="math inline">\(P_{ac} = P_{ac}(x)\)</span> of an airfoil is the point about which the pitching moment, due to the distribution of aerodynamic forces acting on the airfoil surface, is independent of the angle of attack.</p>
      <p><span class="math display">\[
      \frac{\mathrm{d} c_{m, P_{ac}} }{\mathrm{d} \alpha}(x) = 0
      \]</span></p>
      <p>Thin-airfoil theory tells us that the aerodynamic center is located on the chord line, one quarter of the way from the leading to the trailing edge – the so-called quarter-chord point. The value of the pitching moment about the aerodynamic center can also be determined from thin-airfoil theory, but requires a detailed calculation for each speciﬁc shape of camber line. Here, we simply note that, for a given shape of camber line the pitching moment about the aerodynamic center is proportional to the amplitude of the camber, and generally is negative for conventional subsonic (concave down) camber shapes.</p>
      <p>We note <span class="math inline">\(\Delta z_{ac} = z_{P}(x) - z_{ac}\)</span> the longitudinal position of <span class="math inline">\(P_{ac}\)</span> where <span class="math inline">\(P\)</span> is the point at which the pitching moment has been evaluated. The moment computed with respect to point <span class="math inline">\(P_{ac}\)</span>, for the section at lateral position <span class="math inline">\(x\)</span>:</p>
      <p><span class="math display">\[
      \begin{array}{ll}
      &amp;\displaystyle c^2  \, c_{m, P_{ac}}= \left(z_{ac}- z_{pc} \right) \, c \, c_{\ell} \\
      \Rightarrow &amp; \displaystyle c_{m, P_{ac}} = \left(z_{ac}- z_{pc} \right) \, \frac{c_{\ell}}{c} = -z_{pc}\frac{c_{\ell}}{c}  + z_{ac}\frac{c_{\ell}}{c} = c_{m,P} + \Delta z_{ac}\frac{c_{\ell}}{c} 
      \end{array}
      \]</span></p>
      <p>To get the position of the aerodynamic center, we derivate this expression and equal it to zero, admitting that the position of <span class="math inline">\(P_{ac}\)</span> is nearly fixed (this is true until the angle of attack remains not too near from stall):</p>
      <p><span class="math display">\[
      \begin{array}{lll}
      \displaystyle c_{m, P_{ac}} = c_{m,P} + \Delta z_{ac}\frac{c_{\ell}}{c}&amp;&amp; \\
      \displaystyle 
      \displaystyle  \frac{\partial c_{m, P_{ac}} }{\partial \alpha} = 0 &amp; \Rightarrow &amp; \displaystyle  \frac{\partial c_{m, P} }{\partial \alpha} + \frac{c_{\ell}}{c} \underbrace{\frac{\partial z_{ac} }{\partial \alpha}}_{\approx 0}  +  \frac{z_{ac}}{c} \frac{\partial c_{\ell} }{\partial \alpha}= 0\\
      &amp;\displaystyle \Rightarrow &amp; \displaystyle \Delta z_{ac} = c \frac{\partial c_{m,P}}{\partial c_{\ell}}
      \end{array}
      \]</span></p>
      <p>So far, we have computed the aerodynamic center for an airfoil section. The total <em>wing aerodynamic center</em> is defined considering the planform model of the wing. Similarly, we get:</p>
      <p><span class="math display">\[
      \Delta z_{ac} = \bar{c} \frac{\partial c_{m,P}}{\partial c_{\ell}}
      \]</span></p>
      <p>The longitudinal coordinate of the aerodynamic center is thus:</p>
      <p><span class="math display">\[z_{ac} = z_P - \Delta z_{ac}\,.\]</span></p>
      <p>We see that if <span class="math inline">\(P\)</span> is the aerodynamic center, i.e the point at which the pitch moment doest not vary with lift/AoA, then the derivative is 0 and <span class="math inline">\(\Delta z_{ac} = 0\)</span>.</p>
      <p>When <span class="math inline">\(P\)</span> is located exactly at the aircraft gravity center <span class="math inline">\(G\)</span>, <span class="math inline">\(\frac{\partial c_{m,G}}{\partial c_{\ell}} = C_{\textrm{static margin}}\)</span> is called <em>static margin</em> and the aerodynamic center can be computed in the body coordinates system <span class="math inline">\((0, 0, z_G - \bar{c} \,C_{\textrm{static margin}})\)</span></p>
      <p>For a thin airfoil, it can be seen experimentally that the aerodynamic center is located at 1/4 of the chord from the leading edge, and remains nearly fixed in unstalled standard flight configurations.</p>
      <p>By default, in FSX: * Roll and yaw moments tables (AoA tables and stability derivatives) are assumed to be computed using VMO as reference point for moment computation. The consequence is that if user only has tables generated using a different reference point, a correction must be applied. Note that no correction is applied in aero forces kinetic moment computation to take into account the fact that the angular moments equation is written with respect to G. Best way to circumvent this inconsistency for now is to set VMO = G * Pitching moments tables, the location of the point used to create the tables can be explicitely set in AIR file under the form of a longitudinal offset with respect to VMO. If no longitudinal offset in set,it is automatically considered that pitch moment tables are defined relative to the wing aerodynamic center. The kinetic moment correction accounting for the fact the <span class="math inline">\(c_m\)</span> is relative to <span class="math inline">\(P_{ac}\)</span> and not G is accurately computed. The code automatically evaluates the aerodynamic center of the wing <span class="math inline">\((0, 0, z_G - \bar{c} \,C_{\textrm{static margin}})\)</span>, assuming:</p>
      <p><span class="math display">\[
      \frac{\partial c_{m,G}}{\partial c_{\ell}} \approx  \frac{\partial c_{m,ac}}{\partial c_{\ell}}
      \]</span></p>
      <h4 id="neutral-point">Neutral point</h4>
      <p>This is the equivalent of the aerodynamic center but taking into account for the lift induced pitch of the whole plane (especially the tail) instead of only taking into account the wing lift.</p>
      <h3 id="control-description">Control description</h3>
      <h4 id="geometric-description-1">Geometric description</h4>
      <h3 id="aircraft-mechanical-description">Aircraft mechanical description</h3>
      <h4 id="dof-rigid-body-description">6 DOF rigid body description</h4>
      <h5 id="gravity-center">Gravity center</h5>
      <p>The empty aircraft gravity center position <span class="math inline">\(\boldsymbol{x}_G^{empty, r}\)</span> is prescribed by user in the reference datum, in feet, using keyword <em>empty_weight_CG_position = z, x, y</em></p>
      <h5 id="mass-properties">Mass properties</h5>
      <p>Let us note <span class="math inline">\(m_{empty}\)</span> the mass of the aircraft when it is empty. Its is prescribed in lbs using keyword <em>empty_weight_CG_position</em> of section <em>WEIGHT_AND_BALANCE</em> in the configuration file.</p>
      <p><em>CG_forward_limit</em> <em>CG_aft_limit</em></p>
      <p>It is possible to specify an arbitrary number of additional payload stations (passengers, luggages) in Microsoft Flight Simulator. Maximum number of stations is prescribed by user in <em>WEIGHT_AND_BALANCE</em> usin keyword <em>max_number_of_stations</em>.</p>
      <p>Each payload is defined by: * its name * its weight <span class="math inline">\(m_{payload,i} g_{sea level}\)</span> * its position <span class="math inline">\(\boldsymbol{x}_{payload,i}^r\)</span></p>
      <p><em>station_load.i = weight, z, x, y, name</em></p>
      <p>Position of each payload is given in the reference datum frame, in feet. Note that, if additional payloads are set, Microsoft Flight Simulator will recompute: * the new total mass <span class="math inline">\(m = m_empty + \sum_{i}{m_{payload,i}}\)</span> * the resulting moment of the gravitional forces exerted on these additional payloads * the new position of the gravity center relative to datum reference * the new matrix of inertia</p>
      <h4 id="aircraft-attitude-and-euler-angles">Aircraft attitude and Euler angles</h4>
      <p>Aircraft orientation is described in terms of Euler angles as described below:</p>
      <p><img src="./images/AircraftAttitudeEulerAnglesConventions.png"></p>
      <ul>
      <li><span class="math inline">\(\theta_x\)</span> is the pitch angle</li>
      <li><span class="math inline">\(\theta_y\)</span> is the yaw/heading angle</li>
      <li><span class="math inline">\(\theta_z\)</span> is the roll/bank angle</li>
      </ul>
      <p>We note <span class="math inline">\(\boldsymbol{\theta} = \left(\theta_x, \, \theta_y, \, \theta_z\right)\)</span> the rotation vector. The 3 rotations corresponding to the 3 Euler angles must be compounded in a given, chosen, arbitrary order to get the global rotation/orientation/attitude of the plane. The is order is yaw - pitch -roll in FSX.</p>
      <h4 id="static-longitudinal-stability">Static longitudinal stability</h4>
      <h4 id="matrix-of-inertia">Matrix of inertia</h4>
      <p>The matrix of inertia of a solid is symmetric and depends only on the shape and physical nature of the solid object. It is computed relative to a specific point, generally the gravity center <span class="math inline">\(C_G\)</span>:</p>
      <p><span class="math display">\[
      \boldsymbol{\mathcal{J}}_G = \left(
      \begin{array}{lll}
      \displaystyle \int_{B}{\rho^b \left(\left(y-y_{G}\right)^2+\left(z-z_{G}\right)^2\right)}&amp;
      \displaystyle -\int_{B}{\rho^b \left(x-x_{G}\right)\left(y-y_{G}\right)}                &amp;
      \displaystyle -\int_{B}{\rho^b \left(x-x_{G}\right)\left(z-z_{G}\right)}\\\\
      \displaystyle -\int_{B}{\rho^b \left(x-x_{G}\right)\left(y-y_{G}\right)}    &amp;\displaystyle  \int_{B}{\rho^b \left(\left(x-x_{G}\right)^2+\left(z-z_{G}\right)^2\right)} 
      &amp;\displaystyle -\int_{B}{\rho^b \left(y-y_{G}\right)\left(z-z_{G}\right)}\\\\
      \displaystyle -\int_{B}{\rho^b \left(x-x_{G}\right)\left(z-z_{G}\right)}    &amp;\displaystyle -\int_{B}{\rho^b \left(y-y_{G}\right)\left(z-z_{G}\right)}   &amp;\displaystyle\int_{B}{\rho^b\left(\left(x-x_{G}\right)^2+\left(y-y_{G}\right)^2\right)}\\
      \end{array}
      \right)
      \]</span> where <span class="math inline">\(\rho^b\)</span> is the local density of the aircraft body</p>
      <p>For an aircraft, plane or helicopter at least, the expression of the matrix of inertia <em>expressed in the stability frame simplifies due to symmetries in the geometry of the plane: </em> <span class="math inline">\(J_{xz} = 0\)</span> because when taking any cut parallel to plane <span class="math inline">\((Oxz)\)</span>, the profil obtained is symmetric relative to axis (Ox) * <span class="math inline">\(J_{xy} = 0\)</span> because when taking any cut parallel to plane <span class="math inline">\((Oxy)\)</span>, the profil obtained is symmetric relative to axis (Oy)</p>
      <p>Only non-diagonal term <span class="math inline">\(J_{yz} \neq 0\)</span>, which will be very helpful for solving the fondamental 6-DOF rigid body equations described below.</p>
      <p>NB: These relations are of course not true anymore if the aircraft is loaded in an assymetric manner… This case is not fully handled in FSX legacy neither Microsoft Flight Simulator at the moment</p>
      <h2 id="referential-frames-and-conventions">Referential frames and conventions</h2>
      <p>Five different referential frames are used. They are displayed in Figure</p>
      <p><img src="./images/ReferentialFrames.png"></p>
      <h3 id="canonical-inertial-frame">Canonical inertial frame</h3>
      <p>This frame is located at the center of the earth and does not move in any way. It is considered as a Galileean frame, in which fondamental laws of solid mechanics can be written. It is the only referential we use which does not move in time.</p>
      <h3 id="aircraft-body-frame">Aircraft body frame</h3>
      <p>This frame <span class="math inline">\(\left(O_{FSX}(t), \,\boldsymbol{e}_x^b(t), \,\boldsymbol{e}_y^b(t), \,\boldsymbol{e}_z^b(t)\right)\)</span> is attached to the aircraft body. According to historical FSX conventions, and as stated in FSX/ESP documentation (see below) it is centered “on the centerline chord aft of the leading edge”</p>
      <p><img src="./images/FSXDocStandardPoint.png"></p>
      <p>The <span class="math inline">\((0,0,0)\)</span> point in the model is the visual center when loaded into FSX legacy. The term “centerline chord” is the 1/4 root chord. This is usually the exact same point in the model. By default FS defines the center of lift as the model’s center, which means the center of lift is (by default) defined at the 1/4 root chord position.</p>
      <p>Be careful, this is only true if the modeler did -in fact- set the model’s mesh origin to the 1/4 root chord position. If the modeler chose for some reason to set the model’s origin at the tip of the aircraft’s nose, then all bets are off on the model ever being able to be properly configured!!!</p>
      <p>Be aware that in Microsoft Flight Simulator, this referential is left-handed * <span class="math inline">\(z\)</span> is the longitudinal direction pointing toward the nose of the aircraft; rotation of the aircraft around this axis is named roll or bank. <span class="math inline">\(p\)</span> is the roll velocity rate expressed in the body frame. * <span class="math inline">\(x\)</span> is the side direction pointing toward the right wing typically on a plane; rotation of the aircraft around this axis is named pitch. <span class="math inline">\(q\)</span> is the pitch velocity rate expressed in the body frame. * <span class="math inline">\(y\)</span> is the vertical direction pointing up the aircraft; rotation of the aircraft around this axis is named yaw or heading. <span class="math inline">\(r\)</span> is the yaw velocity rate expressed in the body frame.</p>
      <p>NB: These non-intuitive notations <span class="math inline">\(p\)</span>, <span class="math inline">\(q\)</span>, <span class="math inline">\(r\)</span> are due to the fact that FSX uses these notations which are normally used in the case where the body frame is right-handed and such that x is longitudinal direction, y side direction and z vertical direction pointing downward.</p>
      <p>The body frame is often of interest because the origin and the axes remain fixed relative to the aircraft. This means that the relative orientation of the Earth and body frames describes the aircraft attitude. Also, the direction of the force of thrust is generally fixed in the body frame, though some aircraft can vary this direction, for example by thrust vectoring.</p>
      <p><em>KH_Utils_G.cpp</em> provides routines enabling to pass from quaternion description to PBH (Pitch-Heading-Bank) description: <em>GetPbhFromRotation</em> and <em>GetRotationFromPbh</em> To get the transformation matrix from body coordinates to Earth right-handed coordinates, Euler angles are to be compounded in this order: yaw/pitch/roll.</p>
      <p>Let us adopt the following notations:</p>
      <p><span class="math display">\[
      \begin{array}{lll}
      \textrm{yaw}&amp;c_y = \textrm{cos}\,\theta_y,&amp;  s_y = \textrm{sin}\,\theta_y\\
      \textrm{pitch}&amp;c_x = \textrm{cos}\,\theta_x,&amp;  s_x = \textrm{sin}\,\theta_x\\
      \textrm{roll}&amp;c_z = \textrm{cos}\,\theta_z,&amp;  s_z = \textrm{sin}\,\theta_z
      \end{array}
      \]</span></p>
      <p>And let us coupound the 3 Euler rotations in the required order yaw/pitch/roll to get the transformation matrix:</p>
      <p><span class="math display">\[
      \begin{array}{lll}
      \textrm{yaw}
      &amp;
      &amp;
      \left(
      \begin{array}{lll}
      \phantom{-}c_y &amp; 0 &amp; -s_y \\
      \phantom{-}0 &amp; 1 &amp; 0\\
      s_y &amp; 0 &amp; c_y
      \end{array}
      \right) 
       \\
      \textrm{pitch} &amp;
      \left(
      \begin{array}{lll}
      1 &amp; 0 &amp; 0 \\
      0 &amp;  \phantom{-}c_x &amp; s_x\\
      0 &amp; -s_x &amp; c_x
      \end{array}
      \right)
      &amp; 
      \left(
      \begin{array}{lll}
      \phantom{-}c_y &amp; \phantom{-}0 &amp; -s_y \\
      s_y s_z&amp; \phantom{-}c_x &amp; s_x c_y\\
      c_x s_y &amp; -s_x &amp; c_x c_y
      \end{array}
      \right)
      \\\\
       \textrm{roll} &amp;
      \left(
      \begin{array}{lll}
      \phantom{-}c_z&amp; s_z &amp; 0 \\
      -s_z &amp; c_z &amp; 0\\
      0 &amp; 0 &amp; 1 
      \end{array}
      \right)
      &amp; 
      \left(
      \begin{array}{lll}
      c_z c_y + s_z s_x s_y  &amp;  s_z c_x  &amp; -c_z s_y + s_z s_x c_y\\
      -s_z c_y + c_z s_x s_y  &amp; \phantom{-}c_x c_z &amp; s_z s_y +c_z s_x c_y\\
      c_x s_y                 &amp; -s_x    &amp; \phantom{-}c_x c_y
      \end{array}
      \right)
      \end{array}
      \]</span></p>
      <p>In the code, transformation matrix <span class="math inline">\(\mathcal{R}^{\textrm{body} (z, x, y) \rightarrow \textrm{earth}}\)</span> is given so that vector coordinates in the body frame are given as <span class="math inline">\((z, x, y)\)</span>, which just comes to multiplying the above transformaiton matrix by the permutation matrix like this:</p>
      <p><span class="math display">\[
      \begin{array}{lll}
      &amp;
      \left(
      \begin{array}{lll}
      c_z c_y + s_z s_x s_y  &amp; -s_z c_y + c_z s_x s_y   &amp; c_x s_y \\
      s_z c_x   &amp; \phantom{-}c_x c_z &amp; -s_x\\
      -c_z s_y + s_z s_x c_y                 &amp; s_z s_y +c_z s_x c_y     &amp; \phantom{-}c_x c_y
      \end{array}
      \right)
      &amp;
      \left.
       \left(
      \begin{array}{lll}
      0&amp; 1 &amp; 0 \\
      0 &amp; 0 &amp; 1\\
      1 &amp; 0 &amp; 0 
      \end{array}
      \right)
      \right\} \left(z, x, y\right)  \rightarrow \left(x, y, z\right)
      \\\\
      \underbrace{
       \left(
      \begin{array}{lll}
      0 &amp; 0 &amp; 1 \\
      1 &amp; 0 &amp; 0\\
      0 &amp; 1 &amp; 0 
      \end{array}
      \right)
      }_{ y \leftrightarrow z \textrm{, earth right-handed} (x, y, z) \rightarrow (z, x, y)}
      &amp;
      \left(
      \begin{array}{lll}
      -c_z s_y + s_z s_x c_y                 &amp; s_z s_y +c_z s_x c_y     &amp; \phantom{-}c_x c_y\\
      c_z c_y + s_z s_x s_y  &amp;  -s_z c_y + c_z s_x s_y  &amp; c_x s_y\\
      s_z c_x  &amp; \phantom{-}c_x c_z &amp; -s_x\\
      \end{array}
      \right)
      &amp;
      \left(
      \begin{array}{lll}
      \phantom{-}c_x c_y &amp; -c_z s_y + s_z s_x c_y                 &amp; s_z s_y +c_z s_x c_y     \\
      c_x s_y &amp; c_z c_y + s_z s_x s_y  &amp;  -s_z c_y + c_z s_x s_y   \\
       -s_x &amp; s_z c_x  &amp; \phantom{-}c_x c_z \\
      \end{array}
      \right)
      \end{array}
      \]</span></p>
      <p>We finally get the expression of this transformation matrix as found in the code:</p>
      <p><span class="math display">\[
      \mathcal{R}^{\textrm{body} (z, x, y) \rightarrow \textrm{earth}}
      = 
      \left(
          \begin{array}{lll}
          c_x c_y &amp; s_z s_x c_y - c_z s_y &amp; c_z s_x c_y + s_z s_y\\
          c_x s_y &amp; s_z s_x s_y + c_z c_y &amp; c_z s_x s_y -s_z c_y \\
         - s_x &amp; s_z c_x &amp; c_z c_x
          \end{array}
      \right)
      \]</span></p>
      <h4 id="surface-frame">Surface frame</h4>
      <p>This frame is noted <span class="math inline">\(\left(H(t), \boldsymbol{e}_x^{surf}(t), \boldsymbol{e}_{y}^{surf}(t), \boldsymbol{e}_{z}^{surf}(t)\right)\)</span></p>
      <p><img src="./images/NormalCorrection.png"></p>
      <p><img src="./images/SurfaceFrameAndBodyFrameForContact.png"></p>
      <p>The center of the surface frame is the localization of the current projection <span class="math inline">\(H(t)\)</span> of the gravity center <span class="math inline">\(C_G(t)\)</span> of the plane on the geoid model (AMSL) The surface frame <span class="math inline">\(\left(H, \boldsymbol{e}_{x}^{s}(t), \boldsymbol{e}_{y}^{s}(t), \boldsymbol{e}_{z}^{s}(t)\right)\)</span> is defined as shown on Figure:</p>
      <p><img src="./images/BodyAndSurfaceFrameForContact2.png"></p>
      <p>The yaw of this reference frame is equal to the current yaw of the aircraft body frame, the pitch and roll are obtained by analyzing the local surface normal pitch and roll:</p>
      <p><span class="math display">\[
      \theta_x^{nor} = \textrm{atan}{\left(\frac{n_z}{n_y}\right)}\,, \quad \theta_z^{nor} = \textrm{atan}{\left(\frac{n_x}{n_y}\right)}
      \]</span></p>
      <p><span class="math display">\[
      \begin{array}{ll}
      \boldsymbol{n} &amp;= \displaystyle \left(
          \begin{array}{l}
          \textrm{cos}\left(\frac{\Pi}{2}-\theta_z^{nor}\right)\,\textrm{sin}\left(\theta_x^{nor}\right)\,\textrm{cos}\left(\theta_y^{nor}\right) + \textrm{sin}\left(\frac{\Pi}{2}-\theta_z^{nor}\right)\,\textrm{sin}\left(\theta_y^{nor}\right)\\
          \textrm{cos}\left(\frac{\Pi}{2}-\theta_z^{nor}\right)\,\textrm{sin}\left(\theta_x^{nor}\right)\,\textrm{sin}\left(\theta_y^{nor}\right) - \textrm{sin}\left(\frac{\Pi}{2}-\theta_z^{nor}\right)\,\textrm{cos}\left(\theta_y^{nor}\right) \\
          \textrm{cos}\left(\frac{\Pi}{2}-\theta_z^{nor}\right)\,\textrm{cos}\left(\theta_x^{nor}\right)
          \end{array}
          \right)\\\\
          &amp;= \displaystyle \left(
          \begin{array}{l}
          \textrm{sin}\left(\theta_z^{nor}\right)\,\textrm{sin}\left(\theta_x^{nor}\right)\,\textrm{cos}\left(\theta_y^{nor}\right) + \textrm{cos}\left(\theta_z^{nor}\right)\,\textrm{sin}\left(\theta_y^{nor}\right)\\
          \textrm{sin}\left(\theta_z^{nor}\right)\,\textrm{sin}\left(\theta_x^{nor}\right)\,\textrm{sin}\left(\theta_y^{nor}\right) - \textrm{cos}\left(\theta_z^{nor}\right)\,\textrm{cos}\left(\theta_y^{nor}\right) \\
          \textrm{sin}\left(\theta_z^{nor}\right)\,\textrm{cos}\left(\theta_x^{nor}\right)
          \end{array}
          \right)\\\\
          &amp;= \displaystyle \left(
          \begin{array}{l}
          \textrm{sin}\left(\theta_z^{nor}\right)\,\textrm{sin}\left(\theta_x^{nor}\right) \\
           - \textrm{cos}\left(\theta_z^{nor}\right) \\
          \textrm{sin}\left(\theta_z^{nor}\right)\,\textrm{cos}\left(\theta_x^{nor}\right)
          \end{array}
          \right)\\\\
          &amp; \displaystyle  =
          \left(
          \begin{array}{l}
          \textrm{cos}\left(\theta_z^{s}\right)\,\textrm{sin}\left(\theta_x^{s}\right)\,\textrm{cos}\left(\theta_y^{b}\right) + \textrm{sin}\left(\theta_z^{s}\right)\,\textrm{sin}\left(\theta_y^{b}\right)\\
          \textrm{cos}\left(\theta_z^{s}\right)\,\textrm{sin}\left(\theta_x^{s}\right)\,\textrm{sin}\left(\theta_y^{b}\right) - \textrm{sin}\left(\theta_z^{s}\right)\,\textrm{cos}\left(\theta_y^{b}\right) \\
          \textrm{cos}\left(\theta_z^{s}\right)\,\textrm{cos}\left(\theta_x^{s}\right)
          \end{array}
          \right)
          \end{array}
      \]</span> We compute a new normal that has the same pitch and roll as the “real” normal but which has the same yaw as the aircraft body.</p>
      <p>Now we just have to find <span class="math inline">\(\theta^s_x\)</span> and <span class="math inline">\(\theta^s_z\)</span> such that:</p>
      <p><span class="math display">\[
      \left\{
      \begin{array}{l}
      \displaystyle  s_z^n s_x^n = c_z^s s_x^s \,\textrm{cos}\theta_y^b + s_z^s\textrm{sin}\,\theta_y^b\\\\
      \displaystyle  -c_z^n = c_z^s s_x^s \textrm{sin}\,\theta_y^b - s_z^s\textrm{cos}\,\theta_y^b\\\\
      \displaystyle  s_z^n c_x^n = c_z^s c_x^s
      \end{array}
      \right.
      \]</span></p>
      <p><span class="math display">\[
      \left\{
      \begin{array}{ll}
      \displaystyle (1)\times\textrm{cos}\theta_y^b + (2) \times \textrm{sin}\,\theta_y^b \Rightarrow  &amp; \displaystyle s_z^n s_x^n \textrm{cos}\theta_y^b -c_z^n\textrm{sin}\,\theta_y^b   = c_z^s s_x^s \\\\
      \displaystyle (1)\times\textrm{sin}\theta_y^b - (2) \times \textrm{cos}\,\theta_y^b \Rightarrow  &amp; \displaystyle s_z^n s_x^n \textrm{sin}\,\theta_y^b + c_z^n \textrm{cos}\,\theta_y^b = s_z^s\\
      \end{array}
      \right.
      \]</span></p>
      <p>Then by combining linearly the different lines:</p>
      <p><span class="math display">\[
      \left\{
      \begin{array}{ll}
      \displaystyle (1)\times\frac{1}{s_z^n c_x^n = c_z^s c_x^s} \Rightarrow  &amp; \displaystyle t_x^n \textrm{cos}\theta_y^b -\frac{c_z^n}{s_z^n c_x^n}\textrm{sin}\,\theta_y^b   = t_x^s \\\\
      (2)\displaystyle \times\frac{1}{c_z^s = \frac{s_z^nc_x^n}{c_x^s}} = \frac{c_x^s}{s_z^nc_x^n}\Rightarrow  &amp; \displaystyle c_x^s t_x^n \textrm{sin}\,\theta_y^b + \frac{c_z^n}{c_z^s} \textrm{cos}\,\theta_y^b = t_z^s\\
      \end{array}
      \right.
      \]</span></p>
      <p>which provides values for <span class="math inline">\(\theta^s_x\)</span> and <span class="math inline">\(\theta^s_z\)</span>. (TO BE IMPROVED: I CANNOT EXPLAIN THE FORMULA USED IN THE CODE, <em>sim1_World.cpp, SurfaceInformation::CalculateBodyToSurfaceMatrix</em>. FURTHER INVESTIGATION NEEDED)</p>
      <p>Finally, the transformation matrix from body frame coordinates to surface frame coordinates simply writes like <span class="math inline">\(\mathcal{R}^{\textrm{body} (z, x, y) \rightarrow \textrm{earth} (z, x, y)}\)</span>, using relatives angles and the fact that body and surface frames have the same yaw <span class="math inline">\(\theta_y^s = \theta_y^b\)</span>:</p>
      <p><span class="math display">\[\mathcal{R}^{\textrm{body} (z, x, y) \rightarrow \textrm{surf} (z, x, y)}
      = 
      \left(
          \begin{array}{lll}
          \phantom{-}\textrm{cos}\left(\theta_x^b - \theta_x^s\right)  &amp; \textrm{sin}\left(\theta_z^b - \theta_z^s\right) \textrm{sin}\left(\theta_x^b - \theta_x^s\right) &amp; \phantom{-}\textrm{cos}\left(\theta_z^b - \theta_z^s\right) \textrm{sin}\left(\theta_x^b - \theta_x^s\right) \\
          \phantom{-}0 &amp; \textrm{cos}\left(\theta_z^b - \theta_z^s\right)  &amp;  -\textrm{sin}\left(\theta_z^b - \theta_z^s\right)  \\
         - \textrm{sin}\left(\theta_x^b - \theta_x^s\right)&amp; \textrm{sin}\left(\theta_z^b - \theta_z^s\right) \textrm{cos}\left(\theta_x^b - \theta_x^s\right) &amp; \phantom{-} \textrm{cos}\left(\theta_z^b - \theta_z^s\right) \textrm{cos}\left(\theta_x^b - \theta_x^s\right)
          \end{array}
      \right)
      \]</span></p>
      <h4 id="stability-lift-and-drag-frame">Stability (lift and drag) frame</h4>
      <p>This frame is noted <span class="math inline">\(\left(O_{FSX}(t), \,\boldsymbol{e}_x^{stab}(t), \,\boldsymbol{e}_y^{stab}(t), \,\boldsymbol{e}_z^{stab}(t)\right)\)</span></p>
      <p>The current angle of attack (AoA) <span class="math inline">\(\alpha(t)\)</span> of the aircraft is the angle formed between the current longitudinal velocity direction of the aircraft and the current longitudinal direction <span class="math inline">\(z\)</span> of the body referential:</p>
      <p><span class="math display">\[
      \textrm{tan}\left(\alpha(t)\right)= \frac{v_y^b}{v_z^b}\,, \quad \textrm{sometimes noted } = \frac{w}{u}
      \]</span></p>
      <p>The current side slip angle <span class="math inline">\(\beta(t)\)</span> of the aircraft is the angle formed between the current side velocity direction of the aircraft and the current longitudinal direction <span class="math inline">\(z\)</span> of the body referential:</p>
      <p><span class="math display">\[
      \textrm{tan}\left(\beta(t)\right) = \frac{v_x^b}{v_z^b}\,, \quad \textrm{sometimes noted } = \frac{v}{u}
      \]</span></p>
      <p>The stability frame is used for the computation of lift and drag forces. It is just a rotation of the body frame around body frame axis <span class="math inline">\(\boldsymbol{e}_x^b\)</span> (pitch) of angle <span class="math inline">\(\alpha = \alpha(t)\)</span> corresponding to the current Angle of Attack (AoA) of the aircraft.</p>
      <p><span class="math display">\[
      \left\{
      \begin{array}{ll}
      \displaystyle \boldsymbol{e}_x^{\textrm{stab}}(t) &amp;\displaystyle = \boldsymbol{e}_x^b(t)\\
      \displaystyle \boldsymbol{e}_y^{\textrm{stab}}(t)&amp; \displaystyle =-\sin{\left(\alpha(t)\right)} \,\boldsymbol{e}_z^b(t) + \cos{\left(\alpha(t)\right)} \,\boldsymbol{e}_y^b(t)\\
      \displaystyle \boldsymbol{e}_z^{\textrm{stab}}(t) &amp;\displaystyle = \phantom{-}\cos{\left(\alpha(t)\right)}\, \boldsymbol{e}_z^b(t) + \sin{\left(\alpha(t)\right)} \,\boldsymbol{e}_y^b(t)
      \end{array}
      \right.
      \]</span></p>
      <h3 id="reference-datum-frame">Reference datum frame</h3>
      <p>This referential <span class="math inline">\(\left(R_{\textrm{datum}}(t), \,\boldsymbol{e}_x^b(t), \,\boldsymbol{e}_y^b(t), \,\boldsymbol{e}_z^b(t)\right)\)</span> is simply a translation of the body frame from <span class="math inline">\(O_{FSX}\)</span> to an arbitrary reference datum point <span class="math inline">\(R\)</span> provided by the aircraft manufacturer or by user for practical purpose. <span class="math inline">\(R\)</span> coordinates are generally provided in the body frame, i.e with respect to visual model (mesh) center <span class="math inline">\(O_{FSX}\)</span>. The reference datum point <span class="math inline">\(R\)</span> is defined by user using <em>reference_datum_position</em> in <em>WEIGHT_AND_BALANCE</em> section. User provides the 3 coordinates <span class="math inline">\((z, x, y)\)</span> of this point relative to visual model (mesh) center <span class="math inline">\(O_{FSX}\)</span> point ( long: 1/4 MAC, lat: 0, vert: waterline). Coordinates are provided in feet.</p>
      <p>It’s important to understand that the reference datum position is a value used to define just that. The keyword in any description of “reference datum position” is this: <em>arbitrary</em>. In the real world, all aircraft have a reference datum position. It is typically defined in front of the aircraft’s nose at some arbitrary point by the designer. If you leave all values at (0,0,0) in aircraft configuration file, then by default your center of lift, your visual model center and your reference datum position are all in the exact same location. However, if you have the correct reference datum position for the real aircraft and know the offsets of such things as fuel tanks from that reference datum position… then you want to use the reference datum position value in the configuration file to offset it from the (0,0,0) default model center and move it to the real world location. By doing that, you can now use real world measurement information that’s based on the real world reference datum to position pretty much anything.</p>
      <p>The only critical thing to keep in mind is that in FS, aside from the model’s center (0,0,0) which is defined in the model (mesh) file itself, every other positional setting in the aircraft.cfg file is relative to the defined reference datum position.“Since most modelers don’t have access to the”real world engineering data" for the aircraft they are building, they simply set the “reference datum position” to be coincident to the model’s center origin, then use the “by guess and by God” method to set all the other positional entries… :( In short, the “reference datum position” is completely optional and arbitrary, and even in the absence of accurate hard engineering data from which to work, it may be set to whatever is most convenient for the modeler!</p>
      <h2 id="fundamental-equations">Fundamental equations</h2>
      <p><img src="./images/FlightModelLogic.png"></p>
      <h3 id="fundamental-equations-in-inertial-frame">Fundamental equations in inertial frame</h3>
      <p>The Euler equations for solid dynamics are only valid <em>in an inertial frame</em> and read:</p>
      <p><span class="math display">\[
      \left\{
      \begin{array}{lll}
      \displaystyle m \frac{\mathrm{d}\boldsymbol{v}_G}{\mathrm{d}t}          &amp;= ~\sum{\boldsymbol{F}_{ext}}                  &amp; \displaystyle=  \boldsymbol{F}_{\textrm{aero}} +  \boldsymbol{F}_{\textrm{engine}}  + \boldsymbol{F}_{\textrm{ground reaction}}  + \boldsymbol{F}_{\textrm{gravity}} \\\\
      \displaystyle \frac{\mathrm{d}\left(\boldsymbol{\mathcal{J}}_G \boldsymbol{\omega}\right)}{\mathrm{d}t}     &amp; \displaystyle = ~\boldsymbol{\mathcal{M}}_G\left(\sum{\boldsymbol{F}_{ext}}\right) &amp;= \boldsymbol{\mathcal{M}}_G\left( \boldsymbol{F}_{\textrm{aero}}\right) + \boldsymbol{\mathcal{M}}_G\left(\boldsymbol{F}_{\textrm{engine}}\right) + \boldsymbol{\mathcal{M}}_G\left(\boldsymbol{F}_{\textrm{ground reaction}}\right)\,, \\\\
      \displaystyle \textrm{with }                               &amp; \displaystyle \boldsymbol{\mathcal{M}}_G\left(\boldsymbol{F}\right) &amp; \displaystyle  =  \int_{B}{ \bigl[\left(\boldsymbol{s}-\boldsymbol{x}_G\right)\wedge \boldsymbol{F} \bigr] }
      \end{array}
      \right.
      \]</span> and we have used the fact that the kinetic moment of the gravity forces is zero because these forces are applied at gravity center <span class="math inline">\(G\)</span> of the object.</p>
      <h3 id="rewriting-in-the-aircraft-body-frame">Rewriting in the aircraft body frame</h3>
      <h4 id="why">Why?</h4>
      <p>Things are much more complex in three dimensions than in two dimensions. Indeed, the number of parameters needed to describe the dynamics of a rigid body now equals six, hence the name <span class="math inline">\(6\)</span>-DOF problem (<span class="math inline">\(6\)</span>-Degrees-of-Freedom) used for this class of problems. This means that, contrary to the two-dimensional case, System~() must be fully utilized to compute the movement. Moreover, the directions of <span class="math inline">\(\boldsymbol{\theta}\)</span> and <span class="math inline">\(\boldsymbol{\omega}\)</span> are not constant in time anymore, and none of the coefficients of the matrix of inertia remains constant in time when written in the inertial frame. This means that:</p>
      <p><span class="math display">\[
      \frac{\mathrm{d}\left(\boldsymbol{\mathcal{J}}_G\boldsymbol{\omega}\right)}{\mathrm{d}t} ~\neq~ \boldsymbol{\mathcal{J}}_G\frac{\mathrm{d}\boldsymbol{\omega}}{\mathrm{d}t}\,,
      \]</span> as <span class="math inline">\(\boldsymbol{\mathcal{J}}_G\)</span>, written in the canonical basis, is not constant in time anymore.</p>
      <p>To solve these difficulties, the idea is to rewrite these fundamental relations in aircraft body frame. In this frame, the matrix of inertia is constant in time and, as seen above, it is also simplified as <span class="math inline">\(J_{xz} = J_{xy} =0\)</span>:</p>
      <p>In the sequel, we note <span class="math inline">\(\boldsymbol{\mathcal{R}} = \boldsymbol{\mathcal{R}}(t)\)</span> the matrix enabling to pass from the description in basis <span class="math inline">\((\boldsymbol{e}^b_{x},\, \boldsymbol{e}^b_{y},\, \boldsymbol{e}^b_{z})\)</span> to the description in fixed canonical basis <span class="math inline">\((\boldsymbol{e}_{x},\, \boldsymbol{e}_{y},\, \boldsymbol{e}_{z})\)</span>:</p>
      <p><span class="math display">\[
      \begin{array}{ll}
      \boldsymbol{e}_{x}^b(t) &amp;= r_{1x}(t)\boldsymbol{e}_{x}+ r_{1y}(t)\boldsymbol{e}_{y}+r_{1z}(t)\boldsymbol{e}_{z}\\
      \boldsymbol{e}_{y}^b(t) &amp;= r_{2x}(t)\boldsymbol{e}_{x}+ r_{2y}(t)\boldsymbol{e}_{y}+r_{2z}(t)\boldsymbol{e}_{z}\\
      \boldsymbol{e}_{z}^b(t) &amp;= r_{3x}(t)\boldsymbol{e}_{x}+ r_{3y}(t)\boldsymbol{e}_{y}+r_{3z}(t)\boldsymbol{e}_{z}
      \end{array}
      \]</span></p>
      <p><span class="math display">\[
      \boldsymbol{\mathcal{R}} = \boldsymbol{\mathcal{R}}(t) = 
      \left(
      \begin{array}{lll}
      r_{1x}(t)&amp;r_{2x}(t)&amp;r_{3x}(t)\\
      r_{1y}(t)&amp;r_{2y}(t)&amp;r_{3y}(t)\\
      r_{1z}(t)&amp;r_{2z}(t)&amp;r_{3z}(t)
      \end{array}
      \right)
      \]</span></p>
      <p><span class="math display">\[
      \left(
      \begin{array}{l}
      \boldsymbol{e}_{x}^b(t)\\
      \boldsymbol{e}_{y}^b(t)\\
      \boldsymbol{e}_{z}^b(t)
      \end{array}
      \right)
       =
      \boldsymbol{\mathcal{R}}(t)
       *
      \left(
      \begin{array}{l}
      \boldsymbol{e}_{x}\\
      \boldsymbol{e}_{y}\\
      \boldsymbol{e}_{z}
      \end{array}
      \right)
      \]</span></p>
      <p>As the two basis are orthonormal, rotation matrix <span class="math inline">\(\boldsymbol{\mathcal{R}}(t)\)</span> is always an unitary matrix, i.e <span class="math inline">\(\boldsymbol{\mathcal{R}}(t)\boldsymbol{\mathcal{R}}(t)^{T} = \boldsymbol{\mathcal{I}}_3, \, \, \forall\, \, t\)</span>, where <span class="math inline">\(\mathcal{I}_3\)</span> is the identity matrix.</p>
      <h4 id="derivation-of-vectors-written-in-the-body-frame">Derivation of vectors written in the body frame</h4>
      <p>An arbitrary vector <span class="math inline">\(\boldsymbol{v}^{b}(t)\)</span> described in aircraft body frame <span class="math inline">\((\boldsymbol{e}_{x}^b(t),\,\boldsymbol{e}_{y}^b(t),\, \boldsymbol{e}_{z}^b(t))\)</span> has a description <span class="math inline">\(\boldsymbol{v}(t)\)</span> in the fixed inertial frame. The link between these two representations is given by relation:</p>
      <p><span class="math display">\[
      \boldsymbol{v}(t) ~=~  \boldsymbol{\mathcal{R}}(t)\,\boldsymbol{v}^{b}(t)\,.
      \]</span></p>
      <p>As transformation <span class="math inline">\(\boldsymbol{\mathcal{R}}(t)\)</span> itself is time dependent, in general:</p>
      <p><span class="math display">\[
      \frac{\mathrm{d}\boldsymbol{v}(t)}{\mathrm{d}t} \ne \boldsymbol{\mathcal{R}}(t)\frac{\mathrm{d}\boldsymbol{v}^{b}(t)}{\mathrm{d}t}\,.
      \]</span></p>
      <p>The movement of the aircraft body frame must be taken into account while derivating:</p>
      <p><span class="math display">\[
      \displaystyle \frac{\mathrm{d}\boldsymbol{v}(t)}{\mathrm{d}t}       ~=~ \displaystyle \frac{\mathrm{d}\boldsymbol{\mathcal{R}}(t)}{\mathrm{d}t}\boldsymbol{v}^{b}(t)+\boldsymbol{\mathcal{R}}(t)\frac{\mathrm{d}\boldsymbol{v}^{b}(t)}{\mathrm{d}t} ~=~  \frac{\mathrm{d}\boldsymbol{\mathcal{R}}(t)}{\mathrm{d}t}\boldsymbol{\mathcal{R}}^{T}\boldsymbol{v}(t)+\boldsymbol{\mathcal{R}}(t)\frac{\mathrm{d}\boldsymbol{v}^{b}(t)}{\mathrm{d}t}~=~ \displaystyle \boldsymbol{\omega(t)}\wedge {\boldsymbol{v}(t)} + \boldsymbol{\mathcal{R}}(t)\frac{\mathrm{d}\boldsymbol{v}^{b}(t)}{\mathrm{d}t}\,.
      \]</span></p>
      <p>Indeed, by derivating Relation <span class="math inline">\(\boldsymbol{\mathcal{R}}^T(t)\boldsymbol{\mathcal{R}}(t)~=~\boldsymbol{\mathcal{I}}_3\)</span>, we get:</p>
      <p><span class="math display">\[
      \begin{array}{ll}
      &amp;\displaystyle \frac{\mathrm{d} \boldsymbol{\mathcal{R}}(t)}{\mathrm{d}t} \boldsymbol{\mathcal{R}}^{T}(t)~+~\boldsymbol{\mathcal{R}}(t)\frac{\mathrm{d} \boldsymbol{\mathcal{R}}^T(t)}{\mathrm{d} t}~=~ 0 \\\\
      \displaystyle \Rightarrow   &amp; \displaystyle\frac{ \mathrm{d} \boldsymbol{\mathcal{R}}}{\mathrm{d} t}(t)\boldsymbol{\mathcal{R}}^{T}(t) ~=~ -\left(\frac{\mathrm{d}\boldsymbol{\mathcal{R}}{\mathrm{d}t}(t)\boldsymbol{\mathcal{R}}}(t)^T\right)^T \textrm{ ( i.e } \frac{\mathrm{d}\boldsymbol{\mathcal{R}}}{\mathrm{d}t}(t)\boldsymbol{\mathcal{R}}(t)^T  \textrm{ is skew-symmetric) }\\\\
      \displaystyle \Rightarrow   &amp; \displaystyle \exists\,\, \boldsymbol{\omega} ~=~ \boldsymbol{\omega}(t) \in\, \mathbb{R}^3, \,\, \frac{\mathrm{d}\boldsymbol{\mathcal{R}}}{\mathrm{d}t}(t)\boldsymbol{\mathcal{R}}^{T}(t)    ~=~ \displaystyle \left(
      \begin{array}{lll}
      \phantom{-}0            &amp;    -               \omega^b_z(t) &amp;  \phantom{-}\omega^b_y(t)\\ 
      \phantom{-}\omega^b_z(t)    &amp;  \phantom{-}0             &amp;  -        \omega^b_x(t) \\ 
      -           \omega^b_y(t)   &amp;  \phantom{-}\omega^b_x(t)     &amp;  \phantom{-} 0
      \end{array}
      \right) ~=~  \boldsymbol{\omega}(t) \wedge {\cdot}\,,
      \end{array}
      \]</span></p>
      <p>with:</p>
      <p><span class="math display">\[
       \boldsymbol{\omega}^b(t) = \left(\omega_x^b(t),\, \omega^b_y(t),\, \omega^b_z(t)\right) = \left(q,\, r, \,p\right)\,,
       \]</span></p>
      <p><span class="math inline">\(p\)</span> is the roll (bank), <span class="math inline">\(q\)</span> the pitch and <span class="math inline">\(r\)</span> the yaw (heading), <em>all these quantities being expressed in the body frame</em>. The first term <span class="math inline">\(\boldsymbol{\omega}(t)^b \wedge \cdot\)</span> accounts for the movement of the body frame (its rotation) as compared to the inertial frame. <span class="math inline">\(\boldsymbol{\omega}(t)\)</span> is the instantaneous angular speed of the body frame as compared to the inertial frame, written in the canonical, fixed basis <span class="math inline">\((\boldsymbol{e}_{x}, \boldsymbol{e}_{y}, \boldsymbol{e}_{z})\)</span>. We note <span class="math inline">\(\boldsymbol{\omega}^b\)</span> this same angular speed written in moving basis <span class="math inline">\((\boldsymbol{e}^b_{x}(t), \,\boldsymbol{e}^b_{y}(t),\, \boldsymbol{e}^b_{z}(t))\)</span> attached to the body. We have <span class="math inline">\(\boldsymbol{\omega}(t)= \boldsymbol{\mathcal{R}}(t)\boldsymbol{\omega}^b(t)\)</span>. Then, using the invariance property of the cross-product, we have, for any arbitrary vector <span class="math inline">\(\boldsymbol{v}\)</span>:</p>
      <p><span class="math display">\[
      \displaystyle \frac{\mathrm{d}\boldsymbol{v}}{\mathrm{d}t}(t) = \left(\boldsymbol{\mathcal{R}}(t)\boldsymbol{\omega}^b(t)\right)\wedge \boldsymbol{v} +  \boldsymbol{\mathcal{R}}(t)\frac{\mathrm{d}\boldsymbol{v}^{b}(t)}{\mathrm{d}t} = \boldsymbol{\mathcal{R}}(t)\left(\boldsymbol{\omega}^b(t)\wedge {\boldsymbol{v}^b(t)} +  \frac{\mathrm{d}\boldsymbol{v}^{b}(t)}{\mathrm{d}t}\right)\,.
      \]</span></p>
      <h4 id="final-formulation-as-used-in-microsoft-flight-simulator">Final formulation as used in Microsoft Flight Simulator</h4>
      <h5 id="momentum-conservation-equation">Momentum conservation equation</h5>
      <p>Using Formula~( to rewrite <span class="math inline">\(\frac{\mathrm{d}\left(\boldsymbol{\mathcal{J}}_G \boldsymbol{\omega}\right)}{\mathrm{d}t}\)</span> in System~(), we get:</p>
      <p><span class="math display">\[
      \begin{array}{lll}
                  &amp;\displaystyle \frac{\mathrm{d}\left(\mathcal{J}_G\boldsymbol{\omega}\right)}{\mathrm{d}t} ~=~ \boldsymbol{\mathcal{M}}_{G}\left(\sum{\boldsymbol{F}_{ext}}\right) ~\Rightarrow ~   \boldsymbol{\mathcal{R}}(t)\left( {\boldsymbol{\omega}^b}\wedge {\mathcal{J}_G^b\boldsymbol{\omega}^b} ~+~ \frac{\mathrm{d}\left(\mathcal{J}_G^b\boldsymbol{\omega}^b\right) }{\mathrm{d}t}\right)   \displaystyle ~=~ \boldsymbol{\mathcal{R}}(t) \boldsymbol{\mathcal{M}}^b_{G}\left(\sum{\boldsymbol{F}_{ext}}^b\right) \\\\
      \Rightarrow     &amp;\displaystyle  {\boldsymbol{\omega}^b}\wedge {\mathcal{J}_G^b\boldsymbol{\omega}^b} ~+~ \frac{\mathrm{d}\left(\mathcal{J}_G^b \boldsymbol{\omega}^b\right) }{\mathrm{d}t} ~=~  \boldsymbol{\mathcal{M}}^b_{G}\left(\sum{\boldsymbol{F}_{ext}}^b\right) ~ \Rightarrow ~     {\boldsymbol{\omega}^b} \wedge {\mathcal{J}_G^b\boldsymbol{\omega}^b} ~+~ \mathcal{J}_G^b\frac{\mathrm{d} \boldsymbol{\omega}^b }{\mathrm{d}t}  ~=~  \boldsymbol{\mathcal{M}}^b_{G}\left(\sum{\boldsymbol{F}_{ext}}^b\right)\,,
      \end{array}
      \]</span></p>
      <p>and <span class="math inline">\(\mathcal{J}_G^b\)</span> written in the body referential frame associated with the plane is invariant in time and has helpfully some terms which are zero. Term <span class="math inline">\({\boldsymbol{\omega}^b}\wedge {\boldsymbol{\mathcal{J}}_G^b\boldsymbol{\omega}^b}\)</span> can be developped as:</p>
      <p><span class="math display">\[
      \left(
      \begin{array}{lll}
      \phantom{-}0                &amp;    -               \omega^b_z         &amp;  \phantom{-}\omega^b_y\\ 
      \phantom{-}\omega^b_z   &amp;  \phantom{-}0             &amp;  -            \omega^b_x \\ 
      -           \omega^b_y  &amp;  \phantom{-}\omega^b_x    &amp;  \phantom{-} 0
      \end{array}
      \right)
      \left(
      \begin{array}{lll}
      J^b_{xx}    &amp; 0         &amp; 0\\
      0       &amp; \phantom{-}J^b_{yy}   &amp; -J^b_{yz}\\
      0       &amp; -J^b_{yz}         &amp; \phantom{-}J^b_{zz}
      \end{array}
      \right)
      \left(
      \begin{array}{l}
      \omega^b_x\\
      \omega^b_y\\
      \omega^b_z
      \end{array}
      \right)
      \\
       = 
      \left(
      \begin{array}{lll}
      \phantom{-}0                &amp;    -               p      &amp;  \phantom{-}r\\ 
      \phantom{-}p    &amp;  \phantom{-}0             &amp;  -            q \\ 
      -           r   &amp;  \phantom{-}q &amp;  \phantom{-} 0
      \end{array}
      \right)
      \left(
      \begin{array}{lll}
      J^b_{xx}    &amp; 0         &amp; 0\\
      0       &amp; \phantom{-}J^b_{yy}   &amp; -J^b_{yz}\\
      0       &amp; - J^b_{yz}        &amp; \phantom{-}J^b_{zz}
      \end{array}
      \right)
      \left(
      \begin{array}{l}
      q\\
      r\\
      p
      \end{array}
      \right) 
      \\
      = 
      \left(
      \begin{array}{lll}
      0   &amp; -pJ^b_{yy}-rJ^b_{yz}      &amp; pJ^b_{yz} + rJ^b_{zz}\\
      pJ^b_{xx}       &amp; qJ^b_{yz}&amp; -qJ^b_{zz}\\
      -r J^b_{xx}     &amp;qJ^b_{yy}  &amp; -qJ^b_{yz}
      \end{array}
      \right)
      \left(
      \begin{array}{l}
      q\\
      r\\
      p
      \end{array}
      \right) 
      =
      \left(
      \begin{array}{l}
      r \, p\,\left( J^b_{zz} - J^b_{yy}\right)+ J_{yz}\left(p^2-r^2\right)\\
      p\,q\,\left(J^b_{xx}-J^b_{zz}\right)+q\,r\,J_{yz}\\
      q \, r\,\left( J^b_{yy} - J^b_{xx}\right)- q\,p\,J_{yz}\\
      \end{array}
      \right)\,,
      \]</span></p>
      <p>which finally leads to the following system of equations for the dynamics of rigid bodies:</p>
      <p><span class="math display">\[
      \begin{array}{ll}
      &amp;\displaystyle
      \left(
      \begin{array}{lll}
      J^b_{xx}    &amp; 0         &amp; 0\\
      0       &amp; J^b_{yy}  &amp;-J^b_{yz}\\
      0       &amp; -J^b_{yz}         &amp; J^b_{zz}
      \end{array}
      \right) 
      \left(
      \begin{array}{l}
      \displaystyle \dot{q}\\
      \displaystyle \dot{r}\\
      \displaystyle \dot{p}
      \end{array}
      \right) 
      +
      \left(
      \begin{array}{l}
      r \, p\,\left( J^b_{zz} - J^b_{yy}\right)+ J_{yz}\left(p^2-r^2\right)\\
      p\,q\,\left(J^b_{xx}-J^b_{zz}\right)+q\,r\,J_{yz}\\
      q \, r\,\left( J^b_{yy} - J^b_{xx}\right)- q\,p\,J_{yz}\\
      \end{array}
      \right) = \boldsymbol{\mathcal{M}}^b_{G}\left(\sum{\boldsymbol{F}_{ext}}^b\right) \\\\
      \displaystyle
      \Leftrightarrow &amp; 
      \left(
      \begin{array}{l}
      \displaystyle J^b_{xx}\dot{q} + r \, p\,\left( J^b_{zz} - J^b_{yy}\right)+\left(p^2-r^2\right)\,J_{yz}\\
      \displaystyle  J^b_{yy}\dot{r}-J^b_{yz}\dot{p} + p\,q\,\left(J^b_{xx}-J^b_{zz}\right)+q\,r\,J_{yz} \\
      -J^b_{yz}\dot{r} + J^b_{zz} \dot{p} + q \, r\,\left( J^b_{yy} - J^b_{xx}\right)- q\,p\,J_{yz}
      \end{array} 
      \right)
       = \left(
      \begin{array}{l}
      \displaystyle   M^b_{G,x}\\
      \displaystyle M^b_{G,y}\\
      \displaystyle   M^b_{G,z}
      \end{array}
      \right)
      = \left(
      \begin{array}{l}
      \displaystyle   M\\
      \displaystyle N\\
      \displaystyle   L
      \end{array}
      \right)
      \end{array}
      \]</span></p>
      <p>Thanks to the simple forme of the matrix of inertia of the aircraft written in the body frame, the pitch momentum equation is decorrelated from the others. This is one of the bonuses we get from having struggled to express these equations in the body frame. We directly get, <span class="math inline">\(J_{yz} \leftarrow -J_{yz}\)</span> (because the integral is negative in left handed coordinates?):</p>
      <p><span class="math display">\[
      \displaystyle
      \Leftrightarrow 
      \left\{
      \begin{array}{ll}
      \displaystyle \dot{q}&amp;=\displaystyle \frac{ r \, p\,\left( J^b_{yy} - J^b_{zz}\right)+\left(p^2-r^2\right)\,J_{yz} + M}{J^b_{xx}}\\\\
      \displaystyle \dot{r} &amp;=\displaystyle \frac{ \left(q\,r - \dot{p}\right)\,J_{yz}  + p\,q\,\left(J^b_{zz}-J^b_{xx}\right) + N}{J^b_{yy}}\\\\
      \displaystyle \dot{p}&amp;=\displaystyle \frac{ - \left(q\,p+\dot{r}\right)\,J_{yz} + q \, r\,\left( J^b_{xx} - J^b_{yy}\right)+L}{J^b_{zz}}
      \end{array} 
      \right.\,,
      \]</span></p>
      <p>with <span class="math inline">\(\boldsymbol{\mathcal{M}}^b_{G}\left(\sum{\boldsymbol{F}_{ext}}^b\right)\)</span> given by:</p>
      <p><span class="math display">\[
      \displaystyle \boldsymbol{\mathcal{M}}^b_{G}\left(\sum{\boldsymbol{F}_{ext}}^b\right) = \boldsymbol{\mathcal{R}}(t)^T\boldsymbol{\mathcal{M}}_{G}\left(\sum{\boldsymbol{F}_{ext}}\right)
      = = \boldsymbol{\mathcal{R}}(t)^T\left(\boldsymbol{\mathcal{M}}_{G}\left(\boldsymbol{f}_{\textrm{aero}}\right) + \boldsymbol{\mathcal{M}}_{G}\left(\boldsymbol{f}_{\textrm{engine}}\right) +  \boldsymbol{\mathcal{M}}_{G}\left(\boldsymbol{f}_{\textrm{ground reaction}}\right)\right)\,. 
      \]</span></p>
      <h5 id="quantity-of-movement-conservation-equation">Quantity of movement conservation equation</h5>
      <p>In Microsoft Flight Simulator, for practical reasons, as we have already computed all forces in the aircraft/body referential, we also solve the linear acceleration equation in the body referential frame:</p>
      <p><span class="math display">\[
      \displaystyle m \frac{\mathrm{d}^2\boldsymbol{x}_G^b}{\mathrm{d}t^2}    + {\boldsymbol{\omega}^b}\wedge {\boldsymbol{v}_G^b}    =  \boldsymbol{F}^b_{\textrm{aero}} +  \boldsymbol{F}^b_{\textrm{engine}}  + \boldsymbol{F}^b_{\textrm{ground reaction}}  + \boldsymbol{F}^b_{\textrm{gravity}}\,,
      \]</span></p>
      <p>with <span class="math inline">\(\boldsymbol{\omega}^b = \left(q, \, r, \, p\right)\)</span> and <span class="math inline">\(\boldsymbol{v}^b_G = \left(v^b_{x, G}, \, v^b_{y, G}, \, v^b_{z, G}\right)\)</span>, this leads to:</p>
      <p><span class="math display">\[
      \displaystyle
      \Leftrightarrow 
      \left\{
      \begin{array}{ll}
      \displaystyle m \,\,\left(\dot{v}_{x, G}^b + r\,{v^b_{z, G}}-p\,{v^b_{y, G}}\right)&amp; \displaystyle = X  +  {F}^b_{x, \textrm{gravity}}\\\\
      \displaystyle m\, \,\left(\dot{v}_{y, G}^b+ p\,{v^b_{x, G}}-q\,{v^b_{z, G}} \right)&amp; \displaystyle = Y  +  {F}^b_{y, \textrm{gravity}}\\\\
      \displaystyle m \,\,\left(\dot{v}_{z, G}^b + q\,{v^b_{y, G}}-r\,{v^b_{x, G}} \right)&amp; \displaystyle = Z  +  {F}^b_{z, \textrm{gravity}}
      \displaystyle
      \end{array}
      \right.
      \]</span></p>
      <p>It is important to note that the point at which the fundamentla equations are written is <span class="math inline">\(G\)</span>, which is different from the center <span class="math inline">\(O_{FSX}\)</span> of the body aircraft frame which serves as a reference to define coordinates.</p>
      <p>As the pitching moment coefficient is given relative to the wing aerodynamic center, we have to be careful to transform the aero forces moment to take into account the fact that we must at end express all moments relative to <span class="math inline">\(G\)</span> for consistency</p>
      <p><span class="math display">\[
      \boldsymbol{M}_{O}(\boldsymbol{F})= \boldsymbol{OM} \wedge \boldsymbol{F} = \boldsymbol{OG} \wedge \boldsymbol{F} + \boldsymbol{GM} \wedge \boldsymbol{F} = \boldsymbol{OG} \wedge \boldsymbol{F} + \boldsymbol{M}_{G}(\boldsymbol{F})
      \]</span></p>
      <p>To get <span class="math inline">\(\boldsymbol{M}_{G}(\boldsymbol{F}_{aero})\)</span>, we just have to correct the moment <span class="math inline">\(\boldsymbol{M}_{O}(\boldsymbol{F}_{aero})\)</span> we computed with aerodynamic coefficients with this term <span class="math inline">\(-\boldsymbol{OG} \wedge \boldsymbol{F}_{aero}\)</span> and <span class="math inline">\(\boldsymbol{OG}\)</span> is given by <em>GetCgOfsFromRef</em> in the code.</p>
      <p>This is done in the code in each moment function (<em>PitchMoment</em>, <em>RollMoment</em> and <em>YawMoment</em>) in forces.cpp. For roll moment, this correction is not applied as it is assumed that <span class="math inline">\(G\)</span> and <span class="math inline">\(O\)</span> are located on the centerline <span class="math inline">\(x_O=x_G\)</span> and <span class="math inline">\(y_O=y_G\)</span>.</p>
      <h3 id="linear-perturbations-theory">Linear perturbations theory</h3>
      <h3 id="numerical-integration-at-each-time-step">Numerical integration at each time step</h3>
      <h4 id="state-variables">State variables</h4>
      <h5 id="primary-variables">Primary variables</h5>
      <ul>
      <li>Body center position: <span class="math inline">\(\boldsymbol{x}_G = \left(x^n_G,\, y^n_G, \,z^n_G\right)\)</span> can be transformed in LLA</li>
      <li>Body center velocity: <span class="math inline">\(\boldsymbol{v}_G = \left(v_{x,G}^n,\, v_{y,G}^n, \,v_{z,G}^n\right)\)</span></li>
      <li>Body orientation (rotation) <span class="math inline">\(\boldsymbol{\theta} = \left(\theta^n_x, \,\theta^n_y, \,\theta^n_z\right)\)</span> <em>m_pBodyWorldTransform</em></li>
      <li>Body rotation velocity <span class="math inline">\(\boldsymbol{\theta} = \left(q^n = \omega_x^n, \,r^n = \omega_y^n, \,p^n = \omega_z^n\right)\)</span></li>
      </ul>
      <h5 id="environment-variables">Environment variables</h5>
      <p>Mostly from altitude and atmosphere model * Air density <span class="math inline">\(\rho\)</span> * Speed of sound <span class="math inline">\(c\)</span> <em>speed_of_sound</em> * Ambiant wind</p>
      <h5 id="secondary-variables">Secondary variables</h5>
      <ul>
      <li><p>Relative air speed in body axis <em>f_uvel_body_axis</em> <em>f_vvel_body_axis</em> <em>f_wvel_body_axis</em></p></li>
      <li><p>Total relative speed <span class="math inline">\(U\)</span></p></li>
      <li><p>Mach number <span class="math inline">\(M_a = \frac{U}{c}\)</span> <em>f_mach</em></p></li>
      <li><p>Dynamic pressure <span class="math inline">\(Q = \frac{1}{2} \rho U^2\)</span> <em>f_dyn_pres</em></p></li>
      <li><p>Angle of attack <span class="math inline">\(\alpha\)</span> <em>f_alpha</em></p></li>
      <li><p><span class="math inline">\(\mathcal{R}^n_{\textrm{stab} \rightarrow \textrm{body}}\)</span> <em>f_sin_alpha</em> and <em>f_cos_alpha</em></p></li>
      </ul>
      <p><span class="math display">\[
      \mathcal{R}^n_{\textrm{stab} \rightarrow \textrm{body}} =
      \left(
          \begin{array}{lll}
          1 &amp; 0 &amp; 0\\
          0 &amp; \textrm{cos}(\alpha) &amp; -\textrm{sin}(\alpha)\\
          0 &amp; \textrm{sin}(\alpha) &amp; \phantom{-}\textrm{cos}(\alpha)
          \end{array}
          \right)
      \]</span> In <em>airplane.cpp</em>, routine <em>airplane_body_axis_forces_and_moments</em>: Drag force in classical aerodynamics is positive when pointing toward the back of the plane. Thus a -1 factor must be applied to the z column of the <span class="math inline">\(\mathcal{R}^n_{\textrm{stab} \rightarrow \textrm{body}}\)</span> transformation to take into account that in FSX, <span class="math inline">\(z\)</span> points forward (left-handedness)</p>
      <ul>
      <li>Angle of side slip <span class="math inline">\(\beta\)</span> <em>f_beta</em></li>
      <li>Rotational velocity in stability frame: pitch velocity in stability frame <em>f_pvel_stab_axis</em>, roll (bank) velocity in stability frame <em>f_bvel_stab_axis</em>, yaw (heading) velocity in stability frame <em>f_hvel_stab_axis</em></li>
      </ul>
      <p><span class="math display">\[
      \left[ \mathcal{R}^n_{\textrm{stab} \rightarrow \textrm{body}}\right]^{-1} \left(
          \begin{array}{l}
          q\\r\\p
          \end{array}
          \right)
          = 
      \]</span></p>
      <ul>
      <li><span class="math inline">\(\dot{\alpha}\)</span> <em>alpha_dot</em></li>
      </ul>
      <h4 id="handling-time-step">Handling time step</h4>
      <h4 id="simulation-update">Simulation update</h4>
      <p>The numerical integration is the computation that enables to compute unknown quantities at <span class="math inline">\(t^{n+1}\)</span> from already computed quantities. In _GAMENAME__, we only use quantities at <span class="math inline">\(t^n\)</span> and <span class="math inline">\(t^{n-1}\)</span> and do not go further back in time. The integration method used in _GAMENAME__ is a trapezoidal integration, i.e for a model equation of unknwon <span class="math inline">\(u\)</span> like:</p>
      <p><span class="math display">\[
      \frac{\textrm{d} u}{\textrm{d} t} = F(u, t)
      \]</span></p>
      <p>the value of <span class="math inline">\(u\)</span> at time <span class="math inline">\(t^{n+1} = t^n + \Delta t^n\)</span>, noted <span class="math inline">\(u^{n+1}\)</span>, knowing <span class="math inline">\(u^n\)</span> and <span class="math inline">\(u^{n-1}\)</span>, is computed like this:</p>
      <p><span class="math display">\[
      u^{n+1} = u^{n} + \frac{1}{2}\Delta t^n \, \left(F(u^n, t^n) + F(u^{n-1}, t^{n-1})\right)
      \]</span></p>
      <p>In the code, these equations are solved in file <em>eom.cpp!</em>, function <em>calculate_body_axis_accelerations</em>.</p>
      <p>Our primary unknowns are the 6 velocity DOFs <span class="math inline">\(\left(v^b_{x, G}, \, v^b_{y, G},\, v^b_{z, G},\, q,\, r,\, p\right)\)</span>, related by the equations below:</p>
      <p><span class="math display">\[
      \displaystyle
      \Leftrightarrow 
      \left\{
      \begin{array}{ll}
      \displaystyle
      \begin{array}{ll}
      \displaystyle \dot{v}_{x, G}^b &amp; \displaystyle = \frac{{F}^{b, \textrm{ext}}_{x}}{m} + p\,{v^b_{y, G}}  -r\,{v^b_{z, G}}+ g_x^b  \\\\
      \displaystyle \dot{v}_{y, G}^b&amp; \displaystyle = \frac{{F}^{b, \textrm{ext}}_{y}}{m} + q\,{v^b_{z, G}} - p\,{v^b_{x, G}}+ g_y^b  \\\\
      \displaystyle \dot{v}_{z, G}^b&amp; \displaystyle = \frac{ {F}^{b, \textrm{ext}}_{z}}{m} + r\,{v^b_{x, G}} - q\,{v^b_{y, G}}+ g_z^b 
      \displaystyle
      \end{array}
      &amp;
      \displaystyle
      \begin{array}{ll}
      \displaystyle \dot{q}&amp;=\displaystyle \frac{ r \, p\,\left( J^b_{yy} - J^b_{zz}\right)+\left(p^2-r^2\right)\,J_{yz} + M^b_{G,x}}{J^b_{xx}}\\\\
      \displaystyle \dot{r} &amp;=\displaystyle \frac{ \left(q\,r - \dot{p}\right)\,J_{yz}  + p\,q\,\left(J^b_{zz}-J^b_{xx}\right) + M^b_{G,y}}{J^b_{yy}}\\\\
      \displaystyle \dot{p}&amp;=\displaystyle \frac{ - \left(q\,p+\dot{r}\right)\,J_{yz} + q \, r\,\left( J^b_{xx} - J^b_{yy}\right)+M^b_{G,z}}{J^b_{zz}}
      \end{array} 
      \end{array}
      \right.\,,
      \]</span></p>
      <p>It is important to understand that <span class="math inline">\(\boldsymbol{F}^b = \boldsymbol{F}^b \left(\boldsymbol{x}_G, \boldsymbol{\theta}, \boldsymbol{v}_G, \boldsymbol{\omega} \right)\)</span> and <span class="math inline">\(\boldsymbol{M}^b_G\left(\boldsymbol{x}_G, \boldsymbol{\theta}, \boldsymbol{v}_G, \boldsymbol{\omega}\right)\)</span> are themselves dependent on these 6 unknows, i.e forces and moments obvisouly depend on the translation/rotation velocity and positions of the aircraft,which makes these equations strongly coupled. Note also that in the above equations, all the quantities vary in time except for the coefficients of the matrix of inertia <span class="math inline">\(J_{xx}\)</span>, <span class="math inline">\(J_{yy}\)</span>, <span class="math inline">\(J_{zz}\)</span> and <span class="math inline">\({J_{yz}}\)</span> because they are computed in the body coordinate system (that’s was exactly the objective :-))</p>
      <p>The trapezoidal integration applied to this system gives the following update procedure (for clarity purpose, we remove <span class="math inline">\(^b\)</span> indexation but remain aware that all quantities are to be understood in the body referential frame:</p>
      <p><span class="math display">\[
      \displaystyle
      \Leftrightarrow 
      \left\{
      \begin{array}{ll}
      \displaystyle {v}_{x, G}^{n+1} &amp;\displaystyle = {v}_{x, G}^{n} + \frac{1}{2} \Delta t ^n \left(a_{x,G}^n +  a_{x,G}^{n-1}\right),\,   \\\\
      \displaystyle {v}_{y, G}^{n+1} &amp;\displaystyle = {v}_{y, G}^{n} + \frac{1}{2} \Delta t ^n \left(a_{y,G}^n +  a_{y,G}^{n-1}\right),\,   \\\\
      \displaystyle {v}_{z, G}^{n+1} &amp;\displaystyle = {v}_{z, G}^{n} + \frac{1}{2} \Delta t ^n \left(a_{z,G}^n +  a_{z,G}^{n-1}\right),\,   \\\\
      \displaystyle q^{n+1} &amp;\displaystyle = q^{n} + \frac{1}{2} \Delta t ^n \left(\dot{q}^n +  \dot{q}^{n-1}\right),\,   \\\\
      \displaystyle r^{n+1} &amp;\displaystyle = r^{n} + \frac{1}{2} \Delta t ^n \left(\dot{r}^n +  \dot{r}^{n-1}\right),\,   \\\\
      \displaystyle p^{n+1} &amp;\displaystyle =p^{n} + \frac{1}{2} \Delta t ^n \left(\dot{p}^n +  \dot{p}^{n-1}\right),\,   \\\\
      \end{array}
      \right.\,,
      \]</span></p>
      <p>and current accelerations are evaluated as:</p>
      <p><span class="math display">\[
      \displaystyle
      \Leftrightarrow 
      \left\{
      \begin{array}{ll}
      \displaystyle a_{x,G}^n &amp;\displaystyle  = \frac{{F}^{\textrm{ext}, n}_{x}}{m} + p^n\,{v^{n}_{y, G}}  -r^n\,{v^{n}_{z, G}} + g_x   \\\\
      \displaystyle a_{y,G}^n &amp;\displaystyle  = \frac{{F}^{\textrm{ext}, n}_{y}}{m} +  q^n\,{v^n_{z, G}} - p^n\,{v^n_{x, G}} + g_y \\\\
      \displaystyle a_{z,G}^n &amp;\displaystyle  = \frac{{F}^{\textrm{ext}, n}_{z}}{m} + r^n\,{v^n_{x, G}} - q^n\,{v^n_{y, G}}   + g_z \\\\
      \displaystyle \dot{q}^n &amp;\displaystyle = \frac{ r^n \, p^n\,\left( J_{yy} - J_{zz}\right)+\left(\left(p^n\right)^2-\left(r^n\right)^2\right)\,J_{yz} + M^n_{G,x}}{J_{xx}}\\\\
      \displaystyle \dot{r}^n &amp;\displaystyle = \frac{ \left(q^n\,r^n - \dot{p}^n\right)\,J_{yz}  + p^n\,q^n\,\left(J_{zz}-J_{xx}\right) + M^n_{G,y}}{J_{yy}}\\\\
      \displaystyle \dot{p}^n &amp;\displaystyle = \frac{ - \left(q^n\,p^n+\dot{r}^n\right)\,J_{yz} + q^n \, r^n\,\left( J_{xx} - J_{yy}\right)+M^n_{G,z}}{J_{zz}}
      \end{array}
      \right.\,,
      \]</span></p>
      <p>In the code, accelerations are computed in routine <em>calculate_body_axis_accelerations</em> of file <em>eom.cpp</em>. <span class="math inline">\(\boldsymbol{a}_G^n\)</span> is stored in variable <em>vecAccel</em> and <span class="math inline">\(\boldsymbol{\omega}^n = \left(q^n, r^n, p^n\right)\)</span> is stored in <em>vecRotAccel</em></p>
      <p>Now that we have updated the velocity 6 DOFs, we must also update the 6 position DOFs by integrating the much simpler equations linking accelerations and velocities:</p>
      <p><span class="math display">\[
      \displaystyle
      \Leftrightarrow 
      \left\{
      \begin{array}{ll}
      \displaystyle
      \begin{array}{ll}
      \displaystyle \dot{x}_{G}^b &amp; \displaystyle = {v}_{x, G}^b \\\\
      \displaystyle \dot{y}_{G}^b&amp; \displaystyle =  {v}_{y, G}^b\\\\
      \displaystyle \dot{z}_{G}^b&amp; \displaystyle = {v}_{z, G}^b
      \displaystyle
      \end{array}
      &amp;
      \displaystyle
      \begin{array}{ll}
      \displaystyle \dot{\theta_x}^b&amp;=q\\\\
      \displaystyle \dot{\theta_y}^b &amp;=r\\\\
      \displaystyle \dot{\theta_z}^b&amp;=p
      \end{array} 
      \end{array}
      \right.\,,
      \]</span></p>
      <p>which is integrated simply as:</p>
      <p><span class="math display">\[
      \displaystyle
      \Leftrightarrow 
      \left\{
      \begin{array}{ll}
      \displaystyle {x}_{G}^{n+1} &amp;\displaystyle = {v}_{x, G}^{n} + \frac{1}{2} \Delta t ^n \left(a_{x,G}^n +  a_{x,G}^{n-1}\right),\,   \\\\
      \displaystyle {y}_{ G}^{n+1} &amp;\displaystyle = {v}_{y, G}^{n} + \frac{1}{2} \Delta t ^n \left(a_{y,G}^n +  a_{y,G}^{n-1}\right),\,   \\\\
      \displaystyle {z}_{G}^{n+1} &amp;\displaystyle = {v}_{z, G}^{n} + \frac{1}{2} \Delta t ^n \left(a_{z,G}^n +  a_{z,G}^{n-1}\right),\,   \\\\
      \displaystyle \theta_x^{n+1} &amp;\displaystyle = \theta_x^{n} + \frac{1}{2} \Delta t ^n \left(q^n +  q^{n-1}\right),\,   \\\\
      \displaystyle  \theta_y^{n+1} &amp;\displaystyle = \theta_y^{n} + \frac{1}{2} \Delta t ^n \left(r^n +  r^{n-1}\right),\,   \\\\
      \displaystyle  \theta_z^{n+1} &amp;\displaystyle =\theta_z^{n} + \frac{1}{2} \Delta t ^n \left(p^n +  p^{n-1}\right),\,   \\\\
      \end{array}
      \right.\,,
      \]</span></p>
      <p>The simulation algorithm runs as follows, see <em>SimulateReal</em> in file <em>sim1_exec.cpp</em>. At time step <span class="math inline">\(t^n\)</span>, we know the current translational and angular positions and velocities:</p>
      <p><span class="math display">\[
      x^n_G,\, y^n_G, \,z^n_G, \,\theta^n_x, \,\theta^n_y, \,\theta^n_z, \,v^n_{x,G},\, v^n_{y,G}, \,v^n_{z,G}, \,q^n = \omega_x^n, \,r^n = \omega_y^n, \,p^n = \omega_z^n
      \]</span></p>
      <p>in all the referential frames we want, we also know all the matrices/transformations enabling to pass from one current referential (stab, surf, body, world) to the other:</p>
      <p><span class="math display">\[
      \mathcal{R}^n_{\textrm{world} \rightarrow \textrm{body}},\, \mathcal{R}^n_{\textrm{body} \rightarrow \textrm{surf}},\, \mathcal{R}^n_{ \textrm{stab}\rightarrow \textrm{body} }
      \]</span></p>
      <ol type="1">
      <li><p>Compute all forces <span class="math inline">\(\boldsymbol{F}^{n,b}_{\textrm{aero}}\)</span>, <span class="math inline">\(\boldsymbol{F}^{n,b}_{\textrm{engine}}\)</span>, <span class="math inline">\(\boldsymbol{F}^{n,b}_{\textrm{ground}}\)</span>, maybe other forces. All these forces must be in fine expressed <em>in body frame</em>. Aerodynamic forces are first computed in the stability frame and then transformed in the body frame using <span class="math inline">\(\mathcal{R}^n_{ \textrm{stab}\rightarrow \textrm{body} }\)</span></p></li>
      <li><p>Compute their associated moments relative to gravity center <span class="math inline">\(G\)</span>: <span class="math inline">\(\boldsymbol{M}_{G, \textrm{aero}}^{n,b}\)</span>, <span class="math inline">\(\boldsymbol{M}_{G, \textrm{engine}}^{n,b}\)</span>, <span class="math inline">\(\boldsymbol{M}_{G, \textrm{ground}}^{n,b}\)</span></p></li>
      <li><p>All these forces are added and taken into account in <em>CalculateBodyForcesAndMoments</em></p></li>
      <li><p>Compute current translational and rotational accelerations <span class="math inline">\(\boldsymbol{a}_G^n\)</span> and <span class="math inline">\(\boldsymbol{\omega}^n = \left(q^n, r^n, p^n\right)\)</span> using the above integration procedure. This is done in <em>calculate_body_axis_accelerations</em></p></li>
      <li><p>Perform first trapezoidal integration as described above to get updated translational and angular velocities <span class="math inline">\(\boldsymbol{v}^{b, n+1}_G\)</span> and <span class="math inline">\(\boldsymbol{\omega}^{b, n+1} = \left(q^{n+1}, \, r^{n+1}, \,p^{n+1}\right)\)</span>. This is done in <em>calculate_body_axis_velocities</em>.</p></li>
      <li><p>Perform second trapezoidal integration to get updated translational and angular displacements <span class="math inline">\(\boldsymbol{x}^{b, n+1}_G\)</span> and <span class="math inline">\(\boldsymbol{\theta}^{b, n+1} = \left(\theta_x^{n+1}, \, \theta_y^{n+1}, \,\theta_z^{n+1}\right)\)</span>. This is done at the begin of <em>QuaternionBodyWorldTransform::UpdatePosition</em> in <em>BodyWorldEom.cpp</em></p></li>
      <li><p>Update aircraft position and orientation in world inertial frame, notably for visual update. This is done at the begin of  in </p></li>
      <li><p>Update world to body frame transformation matrix/quaternion: <span class="math inline">\(\mathcal{R}^{n+1}_{\textrm{body} \rightarrow \textrm{world}}\)</span>. This is done in <em>BodyWorldEom.cpp</em> at the end of <em>QuaternionBodyWorldTransform::UpdatePosition</em></p></li>
      <li><p>Update stability to body frame transformation <span class="math inline">\(\mathcal{R}^{n+1}_{ \textrm{stab}\rightarrow \textrm{body} }\)</span>. In the code, it comes to update coefficients <em>f_pvel_stab_axis</em> <em>f_bvel_stab_axis</em> <em>f_hvel_stab_axis</em> (at <span class="math inline">\(C_G\)</span>). This is done at the end of <em>calculate_body_axis_velocities</em> in <em>eom.cpp</em> actually</p></li>
      </ol>
      <h2 id="forces-and-kinetic-moments-computations">Forces and kinetic moments computations</h2>
      <h3 id="aerodynamic-forces">Aerodynamic forces</h3>
      <p>Coefficients usage in FSX. We use the following notations, identical to the ones used in the Flight Model documentation:</p>
      <ul>
      <li><span class="math inline">\(U\)</span> current aircraft translation velocity norm</li>
      <li><span class="math inline">\(Q = \frac{1}{2}\rho U^2\)</span> is the current dynamic pressure</li>
      <li><span class="math inline">\(Q_{\textrm{prop induced}} =\frac{1}{2}\rho\left(2\,U\,U_{\textrm{prop induced}} + U^2\right)\)</span> is the current dynamic pressure due to propeller wash</li>
      <li><span class="math inline">\(\delta_e\)</span> is the current elevator deflection angle</li>
      <li><span class="math inline">\(\delta_s\)</span> is the current spoiler deflection angle</li>
      <li><span class="math inline">\(\delta_r\)</span> is the current rudder deflection angle</li>
      <li><span class="math inline">\(\delta_a\)</span> is the current ailerons absolute deflection angles</li>
      <li><span class="math inline">\(\delta_{f,j}^{\textrm{right}}\)</span> is the current right jth flap deflection angle</li>
      <li><span class="math inline">\(\delta_{f,j}^{\textrm{left}}\)</span> is the current left jth flap deflection angle</li>
      <li><span class="math inline">\(\delta_g\)</span> is the gear percentage of extension</li>
      <li><span class="math inline">\(\lambda_{\textrm{ice}}\)</span> accumulated ice scalar</li>
      <li><span class="math inline">\(M_a\)</span> is the current Mach number of the flow</li>
      <li><span class="math inline">\(\alpha\)</span> the current angle-of-attack</li>
      <li><span class="math inline">\(\beta\)</span> the current side-slip angle</li>
      <li><span class="math inline">\(q\)</span> current pitch rate (in body frame)</li>
      <li><span class="math inline">\(p\)</span> current roll rate (in body frame)</li>
      <li><span class="math inline">\(r\)</span> current yaw rate (in body frame)</li>
      <li><span class="math inline">\(q^{\textrm{stab}}\)</span> current pitch rate (in stability frame)</li>
      <li><span class="math inline">\(p^{\textrm{stab}}\)</span> current roll rate (in stability frame)</li>
      <li><span class="math inline">\(r^{\textrm{stab}}\)</span> current yaw rate (in stability frame)</li>
      </ul>
      <p>Constant values: * <span class="math inline">\(m_{\textrm{empty}}\)</span> mass of empty aircraft * <span class="math inline">\(\alpha_i\)</span> constant horizontal tail incidence angle * <span class="math inline">\(AR\)</span> wings aspect ration * <span class="math inline">\(e\)</span> wings Oswald coefficient * <span class="math inline">\(S\)</span> wings total surface area * <span class="math inline">\(b\)</span> wings span * <span class="math inline">\(c_f\)</span> flaps span outboard length * <span class="math inline">\(\bar{c}\)</span> wings mean chord (computed from user-prescribed gemetrical parameters using trapezoidal wings hypothesis)</p>
      <!-- $$
      C_{\textrm{c\_over\_2u\_qS}}= \frac{1}{4} \rho U S \bar{c} = \underbrace{\frac{1}{2} \rho U^2}_{Q} \times \frac{1}{2 U} \times S \bar{c} = \frac{\bar{c}}{2 U} \,Q S
      $$ -->
      <p>Linearisation hypothesis: forces are expressed in the current stability frame. The lift force (up direction of the stability frame) is computed as follows:</p>
      <h4 id="aerodynamic-translational-forces-in-stability-frame">Aerodynamic translational forces in stability frame</h4>
      <p><span class="math display">\[
      \begin{array}{ll}
      F_{\textrm{lift}} &amp;\displaystyle =
      \left[
          \left({C_L}^{\textrm{base}}_q + {C_L}_q\left(M_a\right)\right)\,q^{\textrm{stab}} + 
          \left(
          {C_L}^{base}_{\dot{\alpha}} + {C_L}_{\dot{\alpha}}(M_a)
          \right)\,\dot{\alpha}
      \right]
      \,\frac{\bar{c}}{2 U} \,Q S \\\\
      &amp;\displaystyle \left[
              \left(
                  \underbrace
                  {
                      {C_L}_{\alpha}(\alpha)\,C_{tuning}
                  }_{\textrm{AoA lift}}+
                  \underbrace
                  {
                  \frac{1}{2}\,
                  C^{\textrm{lift tuning}}_{\textrm{flaps}}{C_L}_{\delta_{f}}
                  \sum_{j=0}^{n_{\textrm{flaps}}}{
                      \left(\delta_{f,j}^{\textrm{right}}+\delta_{f,j}^{\textrm{left}}\right)
                  }
                  }_{\textrm{flaps}}
              \right)
              \,\lambda_{\textrm{ground effect}} \,\lambda_{\textrm{mach on CL}}(M_a)         
              \right.\\\\
      &amp;\displaystyle \left.
              +       
                  \underbrace
                  {
                  \left(
                  {C_L}^{\textrm{base}}_{\delta_e} + {C_L}_{\delta_e}(M_a)\right)\, \textrm{cos}\alpha \,\delta_e
                  }_{\textrm{elevators}} \right.\\\\
      &amp;\displaystyle \left.
              + \underbrace
                  {
                  \left(
                  {C_L}^{\textrm{base}}_{\delta_s} + {C_L}_{\delta_s}(M_a)
                  \right)\, \delta_s
                  }_{\textrm{spoilers}}\right.\\\\
      &amp;\displaystyle \left.
              + \underbrace
                  {
                  {C_L}_{ih} \, \alpha_i^{\textrm{htail}}
                  }_{\textrm{Htail incidence}}
              + \underbrace
                  {
                  {C_L}_{ice}\lambda^{\textrm{ice}}
                  }_{\textrm{ice accumumlation influence on lift}}
      \right]\,Q S
      \end{array}
      \]</span></p>
      <p>The drag is computed as follows, using user input coefficients and tables:</p>
      <p>$$ \begin{array}{ll} F_{} &amp;= ,Q S \end{array} $$</p>
      <p>The side force is computed as follows, using user input coefficients and tables:</p>
      <p><span class="math display">\[
      \begin{array}{ll}
      F_{\textrm{side}} &amp;\displaystyle =
       \left[
                  \underbrace{\left({C_Y}^{\textrm{base}}_p + {C_Y}_p(M_a)\right)\,p^{\textrm{stab}}}_{roll}
                  + \underbrace{\left({C_Y}^{\textrm{base}}_r + {C_Y}_r(M_a)\right)\,r^{\textrm{stab}}}_{yaw}
      \right]\,\frac{b}{2U}QS
      \\\\
      &amp;
      \displaystyle  +
      \left[
                  \underbrace{\left({C_Y}^{\textrm{base}}_{\delta_r} + {C_Y}_{\delta_r}(M_a)\right)\,\delta_r}_{rudder}
                  +\underbrace{\left({C_Y}^{\textrm{base}}_{\beta} + {C_Y}_{\beta}(M_a)\right)\,\beta}_{slip angle}
      \right]\,QS
      \end{array}
      \]</span></p>
      <h4 id="aerodynamic-torques-in-stability-frame">Aerodynamic torques in stability frame</h4>
      <p>The pitch moment (torque) is computed as follows:</p>
      <p><span class="math display">\[
      \begin{array}{ll}
      M &amp;\displaystyle =
       \left[
                  \underbrace{\left({C_m}^{\textrm{base}}_q + {C_m}_q(M_a)\right)\,q^{\textrm{stab}}}_{\textrm{pitch rate}}
                  + \underbrace{\left({C_m}^{\textrm{base}}_{\dot{\alpha}} + {C_m}_{\dot{\alpha}}(M_a)\right)\,\dot{\alpha}}_{\textrm{AoA rate}}
      \right]\,\frac{\bar{c}}{2U}QS\bar{c}
      \\\\
      &amp;
      \displaystyle  +
      \left[
                  \underbrace
                  {
                      \left({C_m}^{\textrm{base}}_{\alpha = 0} + {C_m}_{\alpha = 0}(M_a)
                      \right)\,\lambda_{\textrm{tail damage}}
                      \lambda_{\textrm{tuning}}
                  }_{\textrm{Zero AoA pitch}} 
                  +\underbrace{
                      {C_m}_{\alpha}\left( \alpha\right)
                  }_{\textrm{AoA on pitch}}
      \right]\,QS\bar{c}
      \\\\
      &amp;
      \displaystyle  +
      \left[
                  \underbrace
                  {
                      \left({C_m}^{\textrm{base}}_{\delta_e} + {C_m}_{\delta_e}(M_a)
                      - {C_m}^{\textrm{base}}_{\delta_e}\,\frac{|\delta_t|}{|\delta^{\textrm{max}}_t|}
                      \right)
                       \,\lambda^{\textrm{sca}}_{\textrm{elev.}}(\delta_e)
                       \,\lambda^{AoA}_{\textrm{elev}}(\alpha)
                       \,\lambda^{\textrm{eff}}_{\textrm{tuning}} \,\lambda^{\textrm{real.}}
                      \,\delta_e               
                  }_{\textrm{elevators}} 
                  \right.
                  \\\\
                  &amp;
      \displaystyle  
      \left.
                  \quad \quad  \quad +   \quad \underbrace
                  {
                      \left(
                          {C_m}^{\textrm{base}}_{\delta_t}
                          \,\lambda^{\textrm{eff}}_{\textrm{trim}}
                          \,k^{\textrm{elast}}_{\textrm{trim}}(Q)
                          \,\left(
                              1-\lambda^{\textrm{damage}}_{\textrm{elev}}
                          \right)
                      \right)
                      \,\delta_t
                  }_{\textrm{elevator trim}}
      \right]\,QS\bar{c}
      \\\\
      &amp;
      \displaystyle  +
      \left[
          \underbrace
                  {
                  \frac{1}{2}\,
                  C^{\textrm{pitch tuning}}_{\textrm{flaps}}{C_m}_{\delta_{f}}
                  \sum_{j=0}^{n_{\textrm{flaps}}}{
                      \left(\delta_{f,j}^{\textrm{right}}+\delta_{f,j}^{\textrm{left}}\right)
                  }
                  }_{\textrm{flaps}}
                  +\underbrace
                  {
                      {C_m}^{\textrm{base}}_{\delta_g}
                      \,\delta_g
                  }_{\textrm{gears}}
                  +\underbrace
                  {
                      {C_m}^{\textrm{base}}_{\delta_s}
                      \,\delta_s
                  }_{\textrm{spoilers}}
          \right.
                  \\\\
                  &amp;
      \displaystyle  
      \left.
                  \quad \quad  \quad +   \quad
                  \underbrace
                  {
                      \left(
                          {C_m}^{\textrm{base}}_{ih}
                          + {C_m}^{\textrm{base}}_{ih}(M_a)          \right)
                      \,\left(
                              1-{C_m}^{\textrm{damage}}_{ih}\lambda^{\textrm{damage}}_{\textrm{tail}}
                          \right)
                      \,\lambda^{AoA}_{\textrm{tail}}(\alpha)
                      \,\alpha_i^{\textrm{htail}}
                  }_{\textrm{tail incidence}}
      \right]\,QS\bar{c}
      \\\\
                  &amp; + 
      \displaystyle  
      \underbrace{
      \left[
      \sum_{j = 0}^{n_{\textrm{prop}}}{\omega_j^{\textrm{prop}}\,I_j^\textrm{prop}}\,r
      \right]
      \,\lambda^{\textrm{gyro. preces. on pitch}}
      \,\lambda^{\textrm{gyro. preces. on pitch}}_{\textrm{realism}}
      }_{\textrm{gyroscopic effect}}
      \\\\
                  &amp; + 
      \displaystyle  
      \underbrace{
      \left[
      \left(
          \delta_e - \alpha_i^{\textrm{tail}}
      \right)
      \,S\,\bar{c}\,\times\,Q_{\textrm{prop induced}}
      + {C_m}_{q,\textrm{propwash}} \,q^{\textrm{stab}}\,\left(\textrm{cos}\alpha\right)^2\,\frac{\bar{c}}{2\left(U+U_{\textrm{prop induced}}\right)}Q_{\textrm{prop induced}}\,S\,\bar{c}
      \right]
      }_{\textrm{propeller wash}}
      \\\\
                  &amp; + 
      \displaystyle  
      \underbrace{
      \left[
      \omega_x^{\textrm{turbulence}}\,C_{\textrm{turbulence}}\, \lambda^{\textrm{turbulence}}(m_{\textrm{empty}})
      \right]\,QS\bar{c}
      }_{\textrm{turbulence}} 
      +
      \underbrace{
      \left[
      F_{\textrm{lift}}\,\left(z_G-z_{CoL}-\Delta z_{stall}\right) - F_{\textrm{drag}}\,y_G
      \right]
      }_{\textrm{moment correction } \boldsymbol{GP_{CoL}\wedge \boldsymbol{F}}} 
      \end{array}
      \]</span></p>
      <p>The roll moment is computed as:</p>
      <p><span class="math display">\[
      \begin{array}{ll}
      L &amp;\displaystyle =
       \left[
                  \underbrace
                  {
                      \left(
                          {C_l}^{\textrm{base}}_{beta} + {C_l}_{\beta}(M_a)
                      \right)\,\beta\,\lambda_{\alpha \textrm{ on } Cl_{\beta}}(\alpha)\lambda_{\textrm{realism}}
                  }_{\textrm{side slip}}
                      + \underbrace
                  {
                      {C_l}_{\alpha}(\alpha^{\textrm{lag}})\lambda^{\textrm{spin bias dir}}\lambda_{\textrm{realism}}
                  }_{\textrm{AoA}}
                  + 
      \right]\,QSb
      \\\\
      &amp;
      \displaystyle +
       \left[
                  \underbrace
                  {
                      \left(
                          {C_l}^{\textrm{base}}_{r} + {C_l}_{r}(M_a)
                      \right)\,\,\lambda_{\textrm{cross deriv. washout}}(\frac{\alpha}{\alpha^{\textrm{stall}}})\,\,r^{\textrm{stab}}
                  }_{\textrm{yaw rate}}
                  + \underbrace
                  {
                      \left({C_l}^{\textrm{base}}_{p} + {C_l}_{p}(M_a)\right)\,p^{\textrm{stab}}
                      }_{\textrm{roll rate}}
      \right]\,\frac{\bar{b}}{2U}QSb
      \\\\
      \\\\
      &amp;
      \displaystyle +
       \left[
                  \underbrace
                  {
                      \left(
                          {C_l}^{\textrm{base}}_{\delta r} + {C_l}_{\delta r}(M_a)
                      \right)\,\textrm{cos}\alpha \,\delta_r
                  }_{\textrm{rudder}}
                  + \underbrace
                  {
                      {C_l}^{\textrm{base}}_{\delta_s}
                      \left(
                          \delta_s^{\textrm{left}} - \delta_s^{\textrm{right} }
                      \right)
                  }_{\textrm{spoilers}}
      +
                  \underbrace{
      \left[
      \omega_z^{\textrm{turb.}}\,C_{\textrm{turb.}}\, \lambda^{\textrm{turb.}}(m_{\textrm{empty}})
      \right]\,QS\bar{c}
      }_{\textrm{turbulence}} 
                  \right.\\\\
      &amp;
      \displaystyle +
       \left. \underbrace
                  {
                      \frac{1}{2}\,{C_L}_{\delta_f}\lambda_{\textrm{tuning}}^{\textrm{flaps}}\,\sum_{j=0}^{n_{\textrm{flaps}}}\left(\delta_{f,j}^{\textrm{right}}-\delta_{f,j}^{\textrm{left}}\right)\,\frac{1}{2}\,c_{f}\, b        
                  }_{\textrm{flaps}}
      +
      \underbrace{
      F_{\textrm{side}}\,y_G - F_{\textrm{lift}}\,\left(x_G-x_{\textrm{CoL}}-\Delta x^{\textrm{stall}}\right)
      }_{\textrm{moment correction } \boldsymbol{GP_{CoL}\wedge \boldsymbol{F}}} 
                  \right. \\\\
      \displaystyle +
       &amp;\left.        
      \underbrace
                  {
                      \left(
                          \lambda_{\textrm{ail.}}^{\textrm{scal.}}
                      \,\delta_{a}^{\textrm{left}}
                      +
                      \lambda_{\textrm{ail.}}^{\textrm{scal.}}
                      \,\delta_{a}^{\textrm{right}}
                          \right)
                      \left(
                          \frac{1}{2}\,{C_l}^{\textrm{base}}_{\delta_{a}}
                          + {C_l}^{\textrm{base}}_{\delta_{a}}(M_a)
                      \right)
                      \,\lambda_{\textrm{ail.}}^{\textrm{eff}}
                      \,\lambda_{\textrm{ail.}}^{\textrm{AoA}}(\alpha)
                      \,\lambda_{\textrm{ail.}}^{\textrm{load fac eff}}(g)
                      \,\lambda_{\textrm{ail.}}^{\textrm{real.}}    \,\textrm{cos}(\alpha)
                  }_{\textrm{ailerons}} \right. \\\\
      \displaystyle +
       &amp;\left.        
                   \underbrace
                  {
                      {C_l}^{\textrm{base}}_{\delta_{at}}\,\lambda_{at}^{\textrm{eff}}\,\delta_{at}
                  }_{\textrm{ailerons trim}}
      \right]\,\frac{\bar{b}}{2U}QSb
      + \textrm{ propeller torque } + \textrm{ wing tips damage }
      \end{array}
      \]</span></p>
      <p>Finally, yaw moment is computed as follows:</p>
      <p><span class="math display">\[
      \begin{array}{ll}
      N &amp;\displaystyle =
       \left[
                  \underbrace{
                      \left({C_n}^{\textrm{base}}_r + {C_n}_r(M_a)\right)\,r^{\textrm{stab}}
                  }_{\textrm{yaw damping}}
                  +
                  \underbrace{
                      \left(
                          {C_n}^{\textrm{base}}_p + {C_n}_r(M_a)
                      \right)
                      \,\lambda^{\textrm{cross der. washout}}_{yaw}\left(\frac{\alpha}{\alpha^{\textrm{stall}}}\right)
                      \,p^{\textrm{stab}}
                  }_{\textrm{roll}}
      \right]\,\frac{b}{2U}QSb
      \\\\
      &amp;\displaystyle +
       \left[
      \underbrace{
                      {C_n}_{\alpha}(\alpha^{\textrm{lag}})\lambda^{\textrm{spin bias dir}}\lambda_{\textrm{realism}}
                  }_{\textrm{AoA}}
      +
      \underbrace{
                       \left({C_n}^{\textrm{base}}_{\beta} + {C_n}_{\beta}(M_a) \right)\,\lambda_{{C_n}_{\beta}}(\alpha)\,\left(1-\lambda^{\textrm{damage}}_{{C_n}_{\beta}}\right)
                  }_{\textrm{side slip}}
                  \right.
      \\\\
      &amp;\displaystyle +
       \left.
                  \underbrace{
                      \left({C_n}^{\textrm{base}}_{\delta r} + {C_n}_{\delta r}(M_a)\right)\,\lambda_{{C_n}_{\delta_r}}(\alpha)\,\lambda^{\textrm{scaling}}_{{C_n}_{\delta_r}}(\delta_r)
                  }_{\textrm{rudder}}
                  +
                  \underbrace{
                      {C_n}^{\textrm{base}}_{\delta r t} \delta_{rt}
                  }_{\textrm{rudder trim}} 
                  \right.
      \\\\
      &amp;\displaystyle \left.
      +
                  \underbrace{
                      {C_n}^{\textrm{base, prop wash}}_{\delta r}\,\left(
                          \delta_r S b Q_{\textrm{prop induced}} b
                      + r^{\textrm{stab}}\left(\textrm{cos}\alpha\right)^2
                      \frac{\bar{c}}{2U_{\textrm{prop induced}}} Q_{\textrm{prop induced}} S b 
                      \right)
                  }_{\textrm{propeller wash on rudder}}
       \right.      
      \\\\
      &amp;\displaystyle +
       \left.
      +
      \underbrace{
                      \left(
                          {C_n}^{\textrm{base}}_{\delta a} + {C_n}_{\delta a}(M_a)
                      \right)\,\textrm{cos}\,\alpha
                  }_{\textrm{ailerons}}
                  \right.
      \\\\
      &amp;\displaystyle 
       \left.
               +   \underbrace
                  {
                      \frac{1}{2}\,{C_D}_{\delta_f}\lambda_{\textrm{tuning}}^{\textrm{flaps}}\,\sum_{j=0}^{n_{\textrm{flaps}}}\left(\delta_{f,j}^{\textrm{right}}-\delta_{f,j}^{\textrm{left}}\right)\,\frac{1}{2}\,c_{f}\, b
                  }_{\textrm{flaps}}
               +  \underbrace{
      F_{\textrm{drag}}\,\left(x_G - x_{\textrm{CoL}}\right) - F_{\textrm{side}}\,\left(z_G-z_{\textrm{CoL}}-\Delta z^{\textrm{stall}}\right)
      }_{\textrm{moment correction } \boldsymbol{GP_{CoL}\wedge \boldsymbol{F}}} 
       \right]\,Q \,S\,b
      \\\\
      &amp;\displaystyle 
       + \textrm{gyroscopic effect on yaw}
                  + \textrm{Pfactor moment}
                  + \textrm{External Tank moment}\\\\
      \end{array}
      \]</span></p>
      <table>
      <colgroup>
      <col style="width: 33%">
      <col style="width: 33%">
      <col style="width: 33%">
      </colgroup>
      <thead>
      <tr class="header">
      <th>Property</th>
      <th>Description</th>
      <th>measure</th>
      </tr>
      </thead>
      <tbody>
      <tr class="odd">
      <td>compute_aero_center</td>
      <td>Need to compute aerocenter from lift and pitch moment AoA curves</td>
      <td>boolean 1=true, 0 = false</td>
      </tr>
      <tr class="even">
      <td><span style="color:red">aero_center_lift</span></td>
      <td>Longitudinal position <span class="math inline">\(z_{CoL}\)</span> of the center of lift (only active if compute_aero_center = 1)</td>
      <td>feet</td>
      </tr>
      <tr class="odd">
      <td>lift_coef_delta_elevator</td>
      <td><span class="math inline">\({C_L}^{\textrm{base}}_{\delta_e}\)</span> Influence of elevator deflection angle on lift</td>
      <td>adimensional</td>
      </tr>
      <tr class="even">
      <td>lift_coef_horizontal_incidence</td>
      <td></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td><span style="color:red">lift_coef_flaps</span></td>
      <td><span class="math inline">\({C_L}^{\textrm{base}}_{\delta_f}\)</span> Influence of flaps on lift</td>
      <td>adimensional</td>
      </tr>
      <tr class="even">
      <td>lift_coef_spoilers</td>
      <td><span class="math inline">\({C_L}^{\textrm{base}}_{\delta_s}\)</span> Influence of spoilers on lift</td>
      <td>adimensional</td>
      </tr>
      <tr class="odd">
      <td>lift_coef_pitch_rate</td>
      <td><span class="math inline">\({C_L}^{\textrm{base}}_{q}\)</span> Influence of pitch rate q on lift</td>
      <td></td>
      </tr>
      <tr class="even">
      <td>lift_coef_daoa</td>
      <td><span class="math inline">\({C_L}^{\textrm{base}}_{\dot{\alpha}}\)</span> Influence of AoA rate on pitch</td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>lift_coef_ground_effect_mach_table</td>
      <td><span class="math inline">\(\lambda_{\textrm{ground effect}}(M_a)\)</span> Scalar coefficient table function of Mach number, correcting basic lift (Cl vs alpha + flaps) lift depending on ground effect</td>
      <td></td>
      </tr>
      <tr class="even">
      <td>lift_coef_mach_table</td>
      <td><span class="math inline">\(\lambda_{\textrm{mach}}(M_a)\)</span> Scalar coefficient correcting basic lift depending on Mach number</td>
      <td></td>
      </tr>
      <tr class="odd">
      <td><span style="color:red">lift_coef_aoa_table</span></td>
      <td><span class="math inline">\({C_L}_{\alpha}(\alpha)\)</span> Lift function of AoA table. Influence CoL computation if not prescribed and stall angle computation (stall angle = angle for which this table reaches its maximum value)</td>
      <td>adimensional</td>
      </tr>
      <tr class="even">
      <td>lift_coef_delta_elevator_mach_table</td>
      <td><span class="math inline">\({C_L}_{\delta_e}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>lift_coef_daoa_mach_table</td>
      <td><span class="math inline">\({C_L}_{\dot{\alpha}}(M_a)\)</span></td>
      <td>adimentsional</td>
      </tr>
      <tr class="even">
      <td>lift_coef_pitch_rate_mach_table</td>
      <td><span class="math inline">\({C_L}_{q}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>lift_coef_horizontal_incidence_mach_table</td>
      <td><span class="math inline">\({C_L}_{ih}(M_a)\)</span> Horizontal tail incidence on lift</td>
      <td></td>
      </tr>
      <tr class="even">
      <td><span style="color:red">drag_coef_zero_lift</span></td>
      <td><span class="math inline">\({C_D}_0\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td><span style="color:red">drag_coef_flaps</span></td>
      <td><span class="math inline">\({C_D}_{\delta_f}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>drag_coef_gear</td>
      <td><span class="math inline">\({C_D}_{\textrm{gears}}\)</span> Drag due to retractable gears</td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>drag_coef_spoilers</td>
      <td><span class="math inline">\({C_D}_{\delta_s}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>drag_coef_zero_lift_mach_tab</td>
      <td><span class="math inline">\({C_D}_{0}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>side_force_delta_rudder</td>
      <td><span class="math inline">\({C_Y}_{\delta_r}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>side_force_roll_rate</td>
      <td><span class="math inline">\({C_Y}_{p}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>side_force_yaw_rate</td>
      <td><span class="math inline">\({C_Y}_{r}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>side_force_slip_angle</td>
      <td><span class="math inline">\({C_Y}_{\beta}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>side_force_slip_angle_mach_table</td>
      <td><span class="math inline">\({C_Y}_{\beta}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>side_force_delta_rudder_mach_table</td>
      <td><span class="math inline">\({C_Y}_{\delta_r}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>side_force_yaw_rate_mach_table</td>
      <td><span class="math inline">\({C_Y}_{r}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>side_force_roll_rate_mach_table</td>
      <td><span class="math inline">\({C_Y}_{p}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>pitch_moment_delta_elevator</td>
      <td><span class="math inline">\({C_m}_{\delta e}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>pitch_moment_delta_trim</td>
      <td><span class="math inline">\({C_m}_{\delta t}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>pitch_moment_pitch_damping</td>
      <td><span class="math inline">\({C_m}_{q}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>pitch_moment_aoa_0</td>
      <td><span class="math inline">\({C_m}_{\alpha_0}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>pitch_moment_daoa</td>
      <td><span class="math inline">\({C_m}_{\dot{\alpha}}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>pitch_moment_horizontal_incidence</td>
      <td><span class="math inline">\({C_M}_{ih}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>pitch_moment_flaps</td>
      <td><span class="math inline">\({C_m}_{\delta_f}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>pitch_moment_gear</td>
      <td><span class="math inline">\({C_m}_{\textrm{gears}}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>pitch_moment_spoilers</td>
      <td><span class="math inline">\({C_m}_{\delta_s}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>pitch_moment_delta_elevator_propwash</td>
      <td></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>pitch_moment_pitch_propwash</td>
      <td></td>
      <td></td>
      </tr>
      <tr class="even">
      <td><span style="color:red">pitch_moment_aoa_table</span></td>
      <td><span class="math inline">\({C_m}(\alpha)\)</span> Influence CoL computation if not prescribed</td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>pitch_moment_delta_elevator_mach_table</td>
      <td><span class="math inline">\({C_m}_{\delta_e}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>pitch_moment_daoa_mach_table</td>
      <td><span class="math inline">\({C_m}_{\dot{\alpha}}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>pitch_moment_pitch_rate_mach_table</td>
      <td><span class="math inline">\({C_m}_{q}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>pitch_moment_horizontal_incidence_mach_table</td>
      <td><span class="math inline">\({C_M}_{ih}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>pitch_moment_aoa_0_mach_table</td>
      <td><span class="math inline">\({C_m}_{\alpha_0}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>roll_moment_delta_aileron</td>
      <td><span class="math inline">\({C_l}_{\delta_a}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>roll_moment_roll_damping</td>
      <td><span class="math inline">\({C_l}_{p}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>roll_moment_yaw_rate</td>
      <td><span class="math inline">\({C_l}_{r}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>roll_moment_delta_rudder</td>
      <td><span class="math inline">\({C_l}_{\delta_r}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>roll_moment_slip_angle</td>
      <td><span class="math inline">\({C_l}_{\beta}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>roll_moment_spoilers</td>
      <td><span class="math inline">\({C_l}_{\delta_s}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>roll_moment_delta_aileron_trim_scalar</td>
      <td><span class="math inline">\({C_l}_{\delta^{\textrm{trim}}_a}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>roll_moment_aoa_table</td>
      <td><span class="math inline">\({C_l}_{\alpha}(\alpha)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>roll_moment_delta_aileron_aoa_table</td>
      <td><span class="math inline">\({C_l}_{\delta_a}(\alpha)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>roll_moment_slip_angle_aoa_table</td>
      <td><span class="math inline">\({C_l}_{\beta}(\alpha)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>roll_moment_roll_rate_aoa_table</td>
      <td><span class="math inline">\({C_l}_{p}(\alpha)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>roll_moment_slip_angle_mach_table</td>
      <td><span class="math inline">\({C_l}_{\beta}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>roll_moment_delta_rudder_mach_table</td>
      <td><span class="math inline">\({C_l}_{\delta_r}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>roll_moment_delta_aileron_mach_table</td>
      <td><span class="math inline">\({C_l}_{\delta_a}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>roll_moment_yaw_rate_mach_table</td>
      <td><span class="math inline">\({C_l}_{r}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>roll_moment_roll_rate_mach_table</td>
      <td><span class="math inline">\({C_l}_{p}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>yaw_moment_delta_rudder_trim_scalar</td>
      <td><span class="math inline">\({C_n}_{\delta_{rt}}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>yaw_moment_roll</td>
      <td><span class="math inline">\({C_n}_{p}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>yaw_moment_slip_angle</td>
      <td><span class="math inline">\({C_n}_{\beta}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>yaw_moment_delta_rudder</td>
      <td><span class="math inline">\({C_n}_{\delta_r}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>yaw_moment_delta_aileron</td>
      <td><span class="math inline">\({C_n}_{\delta_a}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>yaw_moment_yaw_damping</td>
      <td><span class="math inline">\({C_n}_{r}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>yaw_moment_delta_rudder_propwash</td>
      <td><span class="math inline">\({C_n}^{\textrm{propwash}}_{\delta_r}\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>yaw_moment_yaw_propwash</td>
      <td><span class="math inline">\({C_n}^{\textrm{propwash}}_{r}\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>yaw_moment_slip_angle_aoa_table</td>
      <td><span class="math inline">\({C_n}_{\beta}(\alpha)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>yaw_moment_yaw_rate_aoa_table</td>
      <td><span class="math inline">\({C_n}_{r}(\alpha)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>yaw_moment_slip_angle_mach_table</td>
      <td><span class="math inline">\({C_n}_{\beta}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>yaw_moment_delta_rudder_mach_table</td>
      <td><span class="math inline">\({C_n}_{\delta_r}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>yaw_moment_delta_aileron_mach_table</td>
      <td><span class="math inline">\({C_n}_{\delta_a}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>yaw_moment_yaw_rate_mach_table</td>
      <td><span class="math inline">\({C_n}_{r}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="even">
      <td>yaw_moment_roll_rate_mach_table</td>
      <td><span class="math inline">\({C_n}_{p}(M_a)\)</span></td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>elevator_scaling_table</td>
      <td><span class="math inline">\(\lambda_{\delta_e}(\delta_e)\)</span> This table gives, for each elevator deflecion angle, a coefficient that is used to multiply/tune the elevator deflection angle</td>
      <td></td>
      </tr>
      <tr class="even">
      <td>aileron_scaling_table</td>
      <td><span class="math inline">\(\lambda_{\delta_a}(\delta_a)\)</span> This table gives, for each ailerons deflecion angle, a coefficient that is used to multiply/tune the ailerons deflection angle</td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>rudder_scaling_table</td>
      <td><span class="math inline">\(\lambda_{\delta_r}(\delta_r)\)</span> This table gives, for each rudder deflecion angle, a coefficient that is used to multiply/tune the rudder deflection angle</td>
      <td></td>
      </tr>
      <tr class="even">
      <td>aileron_load_factor_effectiveness_table</td>
      <td><span class="math inline">\(\lambda_{{C_l}_{\delta_a}}(g)\)</span> Scaling of roll_moment_delta_aileron versus gravity forces, G effects on aileron effectiveness, acts on roll_moment_delta_aileron</td>
      <td></td>
      </tr>
      </tbody>
      </table>
      <p>Induced drag: drag induced by lift Parasitic drag: form drag, skin friction drag, interference drag Wave drag (transonic and supersonc) Ram drag</p>
      <p>Potential flow theory $ =  $ linked to irrotational flow hypothesis <span class="math inline">\(\boldsymbol{\boldsymbol{U}} = 0\)</span> In this case, if the fluid is incompressible, potential <span class="math inline">\(\Phi\)</span> is harmonic, i.e solution of <span class="math inline">\(\Delta \phi = 0\)</span> A conformal mapping is a mapping that preserves angles and orientations locally. Generally, it is a complex function. Conformal mappings preserve harminc functions i.e fields which are harmonic in the source domain are also harminic in the image domain. This is useful fo physical problems to get harmonic solutions around complex geometry by knowing harmonic solutions around simple geometry and transpose them around more complex geometries through conformal mapping Joukowski theory uses this conformal mapping:</p>
      <p><span class="math display">\[
      \boldsymbol{z} \rightarrow \boldsymbol{z}+ \frac{1}{\boldsymbol{z}}
      \]</span></p>
      <p>to transform cylinders into airfoil profiles (with cusp trailing edge) The potential flow (i.e harmonic) solution around a cylinder is analytical and well known.</p>
      <p><span class="math display">\[
      \left\{
          \begin{array}{ll}
          V_r &amp;\displaystyle = U_{\infty}\left(1-\frac{R^2}{r^2}\right)\textrm{cos}\theta\\
      V_{\theta} &amp;\displaystyle = -U_{\infty}\left(1+\frac{R^2}{r^2}\right)\textrm{sin}\theta\\
      p&amp;\displaystyle =\frac{1}{2}\rho U_{\infty}^2 \left(2 \frac{R^2}{r^2} \textrm{cos}\left(2\theta\right) - \frac{R^4}{r^4}\right) +p_{\infty}
          \end{array}
      \right.
      \]</span></p>
      <p>The solution of flow around a cylinder tells us that we should expect to find two stagnation points along the airfoil the position of which is determined by the circulation around the profile. There is a particular value of the circulation that moves the rear stagnation point (V=0) exactly on the trailing edge. This condition, which fixes a value of the circulation by simple geometrical considerations is the Kutta condition. «A body with a sharp trailing edge which is moving through a fluid will create about itself a circulation of sufficient strength to hold the rear stagnation point at the trailing edge.»</p>
      <p>The Kutta conditions anbles to reintroduce some “viscous” physics by selecting one specific “physical” solution among all potential flow complex solutions given by the Joulowski theory.</p>
      <p>The theorem applies to two-dimensional flow around a fixed airfoil (or any shape of infinite span). The lift per unit span <span class="math inline">\(L\)</span> of the airfoil is given by:</p>
      <p><span class="math display">\[
      L'(x) = - \rho_{\infty}U_{\infty} \Gamma(x)
      \]</span></p>
      <p>where <span class="math inline">\(\rho_{\infty}\)</span> and <span class="math inline">\(U_{\infty}\)</span>are the fluid density and the fluid velocity far upstream of the airfoil, and <span class="math inline">\(\Gamma(x)\)</span> is the circulation defined as the line integral:</p>
      <p><span class="math display">\[
      \Gamma(x) = \int_{\mathcal{C}}{\boldsymbol{u}(\boldsymbol{s})\cdot\mathrm{d}\boldsymbol{s}}
      \]</span> around a closed contour <span class="math inline">\(\mathcal{C}\)</span> enclosing the airfoil and followed in the positive (anti-clockwise) direction. As explained below, this path must be in a region of potential flow and not in the boundary layer of the cylinder</p>
      <p>For a heuristic argument, consider a thin airfoil of chord <span class="math inline">\(c\)</span> and infinite span, moving through air of density <span class="math inline">\(\rho\)</span> . Let the airfoil be inclined to the oncoming flow to produce an air speed <span class="math inline">\(U\)</span> on one side of the airfoil, and an air speed <span class="math inline">\(U+v\)</span> on the other side. The circulation is then:</p>
      <p><span class="math display">\[
      \Gamma = U c - (U+v)c
      \]</span> The difference in pressure <span class="math inline">\(\Delta p\)</span> between th etwo sides of the airfoil is given by Bernouilli equations:</p>
      <p><span class="math display">\[
      \begin{array}{ll}
      &amp;\frac{\rho}{2}U^2+(p+\Delta p) = \frac{\rho}{2}(U+v)^2+p\\
      \Rightarrow &amp;\frac{\rho}{2}U^2 + \Delta p = \frac{\rho}{2}(U^2 +2Uv + v^2)\\
      \Rightarrow &amp; \Delta p \approx \rho U v
      \end{array}
      \]</span></p>
      <p>So the lift per unit span is:</p>
      <p><span class="math display">\[
      L'(x) = c(x)\Delta p = \rho Uvc= -\rho U \Gamma(x)
      \]</span></p>
      <h4 id="engine-forces">Engine forces</h4>
      <h4 id="contactgear-forces">Contact/gear forces</h4>
      <p><img src="./images/GearWheelOrientation.png"> <img src="./images/GearWheelForce.png"></p>
      <h5 id="normal-reaction">Normal reaction</h5>
      <p><span class="math display">\[
      \boldsymbol{F}_{\textrm{ground reaction}}^b(t) = \mathcal{R}^{\textrm{surf} \rightarrow \textrm{body}}(t)\, \boldsymbol{F}_{\textrm{ground reaction}}^s(t)
      = \left(\mathcal{R}^{\textrm{surf} \rightarrow \textrm{body}}\right)^{-1}(t)\, \boldsymbol{F}_{\textrm{ground reaction}}^s(t)
      \]</span></p>
      <p>The strut force is a “penalization” reaction force, proportional to the vertical penetration of the gear in the ground</p>
      <p><span class="math display">\[
      F_{\textrm{strut}} = K_{\textrm{spring}}\, \underbrace{\textrm{min}\left(\textrm{max}\left(0,\, -y_{\textrm{agl}}\right),\, C_{\textrm{max compression}}\right)}_{\textrm{compression}} -  K_{\textrm{damping}}\, v_y
      \]</span></p>
      <p>This strut force represents the vertical reaction of the ground due to penetration <em>in the aircraft body frame</em>, i.e colinear to aircraft frame vertical direction <span class="math inline">\(\boldsymbol{e}^b_y\)</span>. Using the surface transformation matrix from body to surface frame as expressed above, we get:</p>
      <p><span class="math display">\[
      \begin{array}{ll}
      &amp; \displaystyle  \underbrace{F_y^b}_{\textrm{estimated strut force}} = r_{inv, 20} F_z^s + r_{inv, 21} F_x^s  + r_{inv, 22} F_y^s\\\\
      \Rightarrow &amp; \displaystyle F_y^s = \frac{1}{r_{inv, 22}} \left(F_{strut} - r_{inv, 20} F_z^s - r_{inv, 21} F_x^s\right)
      \end{array}
      \]</span></p>
      <p>Regarding the integration scheme, as <span class="math inline">\(F_x^s\)</span> and <span class="math inline">\(F_z^s\)</span> are not know at <span class="math inline">\(t^n\)</span>, their value at <span class="math inline">\(t^{n-1}\)</span> is used to evaluate <span class="math inline">\(F_y^s\)</span></p>
      <p><span class="math display">\[
      F_y^{s, n} = \frac{1}{r_{inv, 22}} \left(F_{strut, n}  - r_{inv, 20} F_z^{s, n-1} - r_{inv, 21} F_x^{s, n-1}\right)
      \]</span></p>
      <h4 id="rolling-friction-handling">Rolling friction handling</h4>
      <p>The rolling friction force amplitude is computed as follows:</p>
      <p><span class="math display">\[
      F_{\textrm{rolling friction}} = \left(C_{\textrm{rolling resistance}} + C_{\textrm{braking resistance}}\right) \times F_y^s
      \]</span></p>
      <h4 id="side-friction-handling">Side friction handling</h4>
      <p>To compute side friction, we must first define several notions:</p>
      <ul>
      <li>Gear velocity</li>
      </ul>
      <p>The gear velocity in body coordinates is easily computed from the gear position <span class="math inline">\(P_{gear}\)</span> provided by user in the reference datum frame and the current computed state of the aircraft:</p>
      <p><span class="math display">\[
      \boldsymbol{v}^b_{\textrm{wheel}} = \boldsymbol{v}^b_G + \boldsymbol{\omega}^b\wedge \boldsymbol{G P_{\textrm{gear}}}^b
      \]</span></p>
      <ul>
      <li>Steering angle</li>
      </ul>
      <p>In the plane <span class="math inline">\(\left(\boldsymbol{e}^s_x, \boldsymbol{e}^s_z\right)\)</span> locally tangent to the earth surface, the steering angle is the angle between the longitudinal axis of the wheel and the longitudinal direction of the aircraft projected on the plane <span class="math inline">\(\boldsymbol{e}^s_z\)</span> (surface frame has been designed such that surface frame and aircraft body frame have the same yaw/heading).</p>
      <p>It is defined accordung to the user joystick/control input:</p>
      <p><span class="math display">\[
      \theta_{\textrm{steer}} = C_{\textrm{max steering angle}} \times \lambda_{\textrm{steer input}} \times \lambda_{corr}\left(v_{\textrm{wheel}}\right)
      \]</span></p>
      <p>where <span class="math inline">\(\lambda_{\textrm{steer input}}\)</span> is the scaling factor linked to current user seering input and <span class="math inline">\(\lambda_{corr}\)</span> is a correction scaling to avoid over-controlling at faster speeds:</p>
      <p><span class="math display">\[
      \lambda_{corr} = \lambda_{corr}\left(v_{\textrm{wheel}}\right) = \left\{
          \begin{array}{ll}
          1 &amp; \textrm{if } v_{\textrm{wheel}} &lt; v_{\textrm{min}}\\
          1 + (\lambda_{corr, max} -1)\,\frac{v_{\textrm{wheel}}-v_{\textrm{min}}}{v_{\textrm{max}}-v_{\textrm{min}}} &amp; \textrm{if } v_{\textrm{min}} &lt; v_{\textrm{wheel}} &lt; v_{\textrm{max}}\\
          \lambda_{corr, max}&amp; \textrm{if } v_{\textrm{wheel}} &gt; v_{\textrm{max}}\\
          \end{array}
          \right.
      \]</span> with <span class="math inline">\(v_{\textrm{max}} = 50 \,\textrm{fps}\)</span>, <span class="math inline">\(v_{\textrm{min}} = 20 \,\textrm{fps}\)</span>, <span class="math inline">\(\lambda_{corr, max} = 0.25\)</span></p>
      <ul>
      <li>Slip angle The slip angle is the angle between the wheel longitudinal direction of the wheel and the aircraft velocity direction:</li>
      </ul>
      <p><span class="math display">\[
      \theta_{\textrm{slip}} =  \theta_{\textrm{steer}} - \textrm{atan}\left(\frac{v_x^b}{v_z^b}\right)
      \]</span></p>
      <p>The side friction force amplitude is computed as follows:</p>
      <p><span class="math display">\[
      F_{\textrm{side friction}} = C_{\textrm{side friction}} \times \lambda(\theta_{\textrm{slip}})\times F_y^s
      \]</span></p>
      <p>where <span class="math inline">\(\lambda = \lambda(\theta_{\textrm{steer}})\)</span> is a table that enables to weighten the friction depending on the slip angle. If the wheel is orthogonal to the longitudinal direction of the plane, friction is maximal and this coefficient is set to 1. On the contrary, if the wheel is perfectly aligned with the plane advancement direction, it is set to 0 and side friction is null.</p>
      <p>Several empirical/experimental tables are set in hard in the code to provide friction and braking coefficients <span class="math inline">\(C_{\textrm{side friction}}\)</span>, <span class="math inline">\(C_{\textrm{rolling resistance}}\)</span> and <span class="math inline">\(C_{\textrm{braking resistance}}\)</span> depending on: * the type of contact: WHEELS (default), SKIDS, SKIS, SCRAPE POINTS, FLOATS, WATER RUDDER * the type of surface: CONCRETE (default), GRASS, WATER, GRASS_BUMPY, ASPHALT, SHORT_GRASS, LONG_GRASS, HARD_TURF, SNOW, ICE, URBAN, FOREST, DIRT_SURFACE, CORAL_SURFACE, GRAVEL_SURFACE, OIL_TREATED_SURFACE, STEEL_MATS_SURFACE, BITUMINUS, BRICK, MACADAM, PLANKS, SAND, SHALE, TARMAC, WRIGHT_FLYER_TRACK_SURFACE * the surface condition: normal, wet, icy, snow</p>
      <h2 id="microsoft-flight-simulator-new-flight-model">Microsoft Flight Simulator new flight model</h2>
      <h3 id="surface-elements-definition">Surface elements definition</h3>
      <p>First of all, a new surface elements model has been created to better account for the distribution of lift, drag and side forces over the entire aircraft geometry. Compared to XPlane11, our geometrical discretization is more precise. Indeed our model uses 640 surfaces where XPlane11 web site states that « ten elements per side per wing or stabilizer is the maximum ». Our surface elements are spread as follows:</p>
      <ul>
      <li><p><span class="math inline">\(40\times 3\)</span> for the fuselage, assimilated to an elongated rectangular box</p></li>
      <li><p><span class="math inline">\(1\times 3\)</span> for the gears, a box</p></li>
      <li><p><span class="math inline">\(1\times 3\)</span> for each external fuel tank, box</p></li>
      <li><p><span class="math inline">\(20\times 3\)</span> vertical tail and rudder</p></li>
      <li><p><span class="math inline">\(20\times 3\)</span> for horizontal tail and elevators</p></li>
      <li><p><span class="math inline">\(80\times 5\)</span> for each wing</p></li>
      </ul>
      <p><img src="./images/SurfaceElementsGeometry.png"></p>
      <p>As depicted in the above figure, all geometrical elements of the aircraft are taken into account whereas in XPlane11, only the wings, vertical stabilizer, horizontal stabilizer, and propellers are discretized. This means, for instance, that additional drag and pitch due to gears for instance cannot be accounted for in their model.</p>
      <!-- Previous model: from real wing to planform MAC wing model
      Plenty of hypothesis:
      Geometrical
      * dihedral angle?
      * trapezoidal wings

      Cut wings as plenty of airfoils sections and apply for each sectional airfoil
      Need to correct moments ($P_{ac}(x)$)
      Does it improve torque computation du to  -->
      <h3 id="normalization-algorithm">Normalization algorithm</h3>
      <p>This algorithm is used to compute aerodynamics coefficients of each surface element. Indeed, we do not simulate the fluid movement around the aircraft at the moment so we must find a way to tell how each surface elements contribute to lift, drag, side forces and moments. One guideline we want to follow when attributing local aerodynamics coefficients to each surface is to ensure consistency with the classical aerodynamics theory underlying FSX historical flight model. To this aim, an original normalization algorithm has been developed, that helps redistribute global aerodynamics coefficients and tables as provided by user across all surface elements so that the final forces and moments match the ones computed by FSX. Of course, this does not mean we are finally equivalent to FSX modelling, as forces are now distributed over all the aircraft geometry. It rather means that, when suming up all contributions, and thus losing geometrical distribution information, our more general model reduces to FSX historical model. This makes our model an extension of the historical model, which is in accordance with the objective of retro-compatibility. One great advantage of this is to guarantee a consistant behavior for aircrafts designed with the historical model when used in the new model. This requirement is actually of the utmost importance for our client Microsoft.</p>
      <p>The normalization algorithm is performed only once at the beginning of the game session.</p>
      <p>The idea is to pre-compute, during this initialization stage, lift, drag, side and moments normalization coefficients for a pre-defined set of controls configurations. More precisely, 20 configurations involving flaps and spoilers deflections have been chosen. For each of these 20 aircraft controls configurations, 6 normalization coefficients are computed and stored. A detailed explanation of how these normalization coefficients are computed is provided further below.</p>
      <p>During the game, at each simulation step, this big look-up table linking a given controls state to a set of normalization coefficients will be used to linearly interpolate current normalization coefficients from the current aircrafts controls configuration as input by player. This interpolated set of normalization coefficients is then used to uniformly ponderate the lift and drag forces and the moments computed on each surface element, so that the simulation reaches the same global « zero order » solution as the one we would have computed with FSX historical model.</p>
      <p>Now let us explain how these normalization coefficients are computed for each of the 20 chosen aircraft controls configuration during the initialization stage. The algorithm is illustrated in the scheme below.</p>
      <p>Let us consider a given controls configuration, with spoilers and flaps deflection angles set to a given value. We first use FSX model to get the following eight values with the given flaps and spoilers deflection angles: - <span class="math inline">\(C_L(\alpha =0)\)</span> - <span class="math inline">\(\mathrm{d}C_L = \frac{C_L(\alpha = 0.8\,\alpha_{\textrm{stall}}) - C_L(\alpha = 0)}{ (0.8\,\alpha_{\textrm{stall}})}\)</span> - <span class="math inline">\(C_m(\alpha =0)\)</span> - <span class="math inline">\(\mathrm{d}C_m = \frac{C_m(\alpha = 0.8\,\alpha_{\textrm{stall}}) -C_m(\alpha = 0)}{ (0.8\,\alpha_{\textrm{stall}})}\)</span> - Stability derivatives <span class="math inline">\({C_m}_q\)</span>, <span class="math inline">\({C_n}_r\)</span> et <span class="math inline">\({C_l}_p\)</span> at <span class="math inline">\(\alpha = 0\)</span></p>
      <p>We then initialize the algorithm by attributing, to each surface element local lift, drag and moments coefficients, simply by uniformely distributing aerodynamics coefficients and tables provided by user over all surface elements with a basic surface-area-based ponderation. Iterative algorithm: We then iteratively compute the same 8 global coefficients we have retrieved from FSX as explained above, but using the new surface elements model. To do so, the surface elements model is evaluated on 6 different aircraft state: - Zero angle-of-attack (purely frontal relative wind) and aircraft has no rotation speed - 10 degrees angle-of-attack and aircraft has no rotation speed - Purely sided relative wind and aircraft has no rotation speed - Zero angle of attack and aircraft has pure constant pitch velocity of 0.5 FPS - Zero angle of attack and aircraft has pure constant roll velocity of 0.5 FPS - Zero angle of attack and aircraft has pure constant yaw velocity of 0.5 FPS</p>
      <p>These 6 states excite all modes of the surface elements models and enable to estimate the 8 global coefficients <span class="math inline">\(C_L(\alpha =0)\)</span>, <span class="math inline">\(\mathrm{d}C_L\)</span>, <span class="math inline">\(C_D(\alpha =0)\)</span>, <span class="math inline">\(C_m(\alpha =0)\)</span>, <span class="math inline">\(\mathrm{d}C_m\)</span> and stability derivatives.</p>
      <p>At the end of each iteration, we correct surface elements local aerodynamics coeffcients: we uniformly multiply surface elements lift, drag, side and moments coefficients by a ratio comparing FSX/New model, to a posteriori reach FSX global target.</p>
      <p>This evaluation/correction is performed until no correction is needed, i.e correction ratio stagnates to 1.</p>
      <p>At the end of this iterative loop, we have attributed lift/drag/side and moments coefficients to each surface element and we can guarantee that the contributions of all surface elements, when sumed up, lead to the same « zero order » solution as the one previsouly obtained in FSX.</p>
      <p><img src="./images/NormalizationAlgorithm.png"></p>
      <!-- The aim of this algorithm is to compute aerodynamic coefficients for each surface element so that the resulting global behavior of the plane is in accordance with "global" aerodynamics coefficients and tables provided by user.




      Init
      Normalization coefficients are pre-computed at initialization for $N_{\textrm{ctrl states}} = N_{\textrm{flap states}}\times N_{\textrm{spoiler states}}$ input controls configurations
      Spoiler totally active or totally inactive $N_{\textrm{spoiler states}} = 2$
      Number of flaps states $N_{\textrm{flap states}}$ positions, provided by user in *aircraft.cfg*

      For each controls state input (spoiler activated or not and flaps position):


      1. aircraft_evaluate_FSX: returns AC_Evaluation coefficients corresponding to a controls configuration state, computed using FSX old model

      On boucle 10 fois: (pas de verif de la convergence)

      2. aircraft_evaluate_Plane: returns AC_Evaluation coefficients corresponding to a controls configuration state, computed using surface elements

      aircraft_evaluate_Plane works like this
      * Get control state for which we want to compute normalization coefs
      * Recompute surface elements normals aircraft_initplanepoints_new_system: update surface elements for normals to adapt to controls positions/deflections + use currently normalized aero coef (iterative algo)
      * *evaluate_performance*:  This function evaluates lift, drag, side forces and pitch moment using the surface element model for:
          + a given airspeed norm, fixed to cruise speed Vc
          + a given AoA (orientation of relative air vector)
          + a given dynamic state (rotation) of the aircraft

      * Lift, drag, side force and pitch moment are computed by integrating relative wind pressure force on each oriented surface element. The function has different versions, and output CL, CD and the 3 moments coefficients.
      *evaluate_performance* is called 6 times to estimate CL, CD, Cy and Cm, and dCm and dCl and dCmf from 6 aircraft dynamic states: 

          + AoA 0(purely longitudinal relative wind), no rotation speed
          + AoA + 10 degrees, no rotation speed
          + Wind coming from right (total side slip),  no rotation speed
          + AoA 0(purely longitudinal relative wind) + pure pitch velocity
          + AoA 0(purely longitudinal relative wind) + pure roll velocity
          + AoA 0(purely longitudinal relative wind) + pure yaw velocity


      Ci0 = CL0 = AoA 0
      Ci = CL for AoA 10 degrees
      ==> deduce dCL/dAoA = dCi

      Same for Cm0 = Cm at AoA 0
      Cm = Cm at AoA 10 degrees
      ==> dCm


      dCmf = frictional rotation force
      Moments without rotation speed are compared to moments computed with rotation speed (norm = 0.5???)
      Variation du pitch en fonction de la vitesse de rotation de l'avion

      3.  Once *aircraft_evaluate_Plane* has computed *AC_Evaluation*, normalization coefficients are simply obtained by making a ratio between FSX computed coefficients and Microsoft Flight Simulator computed coefficients. This is done in *aircraft_calc_normalization2*. All resulting coefficients are stored in *AC_Normalization* structure
      Normalization coefficients
      * Incidence trim angle ok
      * Tail incidence delta ? not used
      * CiNormalizeToFSX ok 
      * CdNormalizeToFSX ok
      * CdFlapNormalizeToFSX ? not used
      * CybetaNormalizeToFSX ? not used
      * CfmNormalize ok
      * CaForwardTrim ? not used



      All this is done only once at the beginning the the chosen $N_{\textrm{ctrl states}}$ control states.





      In game:
      During the game, the current applicable normalization coefficients are simply deduced by linearly interpolating pre-computed normalization coefficients  using the current input control state.

      Get current controls states

      Update surface elements orientation according to current controls positions/angles

      Interpolation current normalization coefficients from current control states

      Use current normalization to set aerodynamics coefficients of each surface element (to dispatch it actually) function 
      *aircraft_initplanepoints_new_system* that sets all surface elements and their aero coefficients according to selected/interpolated normalization


      To do so,  -->
      <h3 id="complex-physical-phenomena-modelization">Complex physical phenomena modelization</h3>
      <h4 id="stall-modelization-improvements-in-relation-with-surface-elements-model">Stall modelization improvements in relation with surface elements model.</h4>
      <p>When an aircraft is flying normally, the air moves across the wing in a smooth stream. If the aircraft is pitched upwards sufficiently, the air stream becomes less fluid until it finally “detaches” from the wing. This is called a “stall”. FSX had a stall model, but the stalls weren’t entirely native to the simulation. That is, when the conditions for a stall occurred, some additional code would take over to simulate the stall, as a global phenomenon. While using FSX historical flight model, Asobo people and experimented pilots collaborating with Asobo have noticed poor behaviors for limit cases, typically when approaching stall which has motivated the team to put some additional efforts on physical modelling of « limit » flight configurations, which are notoriously badly represented in the classical aerodynamics theory underlying FSX historical flight model.</p>
      <p>The introduction of 3D geometrical information in the flight model through surface elements, as described in the previous paragraph, was clearly a first mandatory step toward improving the physics, as it has enabled the modelization of local phenomena. To better account for stall and all its variants (spin stall, deep stall, simple stall), each surface element has been enriched with a float parameter describing its level of stall. When reaching a certain level of stall, the behavior of the surface is changed using additional parameters so as to follow, broadly speaking, the behavior of a falling plate. Reading the litterature about airfoils behavior in stall configurations, it can indeed be shown that local boundary layer detachment leads to a very sudden change in the aerodynamical behavior of the airfoil, that can be assimilated to a falling plate. The interested reader is refered to this NASA experimentally based study.</p>
      <p>This plate model is used in the new flight model to locally change the behavior of surface elements depending on local stall state. This local stall model enables to accurately simulate classical stall but also spin stall, which is intrinsically impossible with FSX non-geometrical flight model. The effect of geometrically twisted wings on stall, which tends to delay stall as the wing root stalls before the wing tip, is also clearly simulated and can even be depicted in-game using debug mode. In the same way, a spin stall is like a normal stall, but it happens to only one wing of the aircraft. When one wing has lift and the other does not, the flying wing will continue to rise until it flips the plane. Without geometrical input in the flight model, historical FSX model could not really account for spin stall, which is now the case with the new flight model.</p>
      <h4 id="surface-elements-interferences-and-geometrical-self-perturbation-modelization">Surface elements interferences and geometrical self-perturbation modelization</h4>
      <p>We also believe that our new flight model has some notable and measurable advantages over XPlane11 due to surface interdependency: a surface hit by air will create a change in the airflow that will impact all other surfaces behind the first surface, an effect which is essential for simulating: - Engine wash - Shadowing - Deep stall</p>
      <p>Geometrical analysis with respect to the flow direction is performed in the code. This enables to spot which surface elements are shadowed or washed and to temporarily alter their lifting properties accordingly. Future work using the 3D visual model will help improve the computation of occluded/washed surfaces for instance using ray tracing.</p>
    </article>
  </div>
  <script>
	function detectIE() {
	  var ua = window.navigator.userAgent;

	  // Test values; Uncomment to check result …

	  // IE 10
	  // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';

	  // IE 11
	  // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';

	  // Edge 12 (Spartan)
	  // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';

	  // Edge 13
	  // ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586';

	  var msie = ua.indexOf('MSIE ');
	  if (msie > 0) {
		// IE 10 or older => return version number
		return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
	  }

	  var trident = ua.indexOf('Trident/');
	  if (trident > 0) {
		// IE 11 => return version number
		var rv = ua.indexOf('rv:');
		return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
	  }

	  var edge = ua.indexOf('Edge/');
	  if (edge > 0) {
		// Edge (IE 12+) => return version number
		return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
	  }

	  // other browser
	  return false;
	}

	var bIsIE = (detectIE() !== false);

	function setData(name, value)
	{
		if (bIsIE)
		{
			if (localStorage !== undefined)
			{
				if (value === null)
					localStorage.removeItem(name);
				else
					localStorage.setItem(name, value);
			}
			/*var d = new Date();
			d.setTime(d.getTime() + (24*60*60));
			var expires = "expires="+ d.toUTCString();
			document.cookie = name + "=" + value + ";" + expires + ";path=/";
			*/
		}
		else
		{
			if (value === null)
				sessionStorage.removeItem(name);
			else
				sessionStorage.setItem(name, value);
		}
	}
	
	function getData(name)
	{
		var value = null;
		if (bIsIE)
		{
			/*var cname = name + "=";
			var decodedCookie = decodeURIComponent(document.cookie);
			var ca = decodedCookie.split(';');
			for(var i = 0; i <ca.length; i++) {
				var c = ca[i];
				while (c.charAt(0) == ' ') {
					c = c.substring(1);
				}
				if (c.indexOf(cname) == 0) {
					return c.substring(cname.length, c.length);
				}
			}
			return null;*/
			if (localStorage !== undefined)
			{
				value = localStorage.getItem(name);
			}
			if (value === 'undefined')
				value = null;
		}
		else
		{
			value = sessionStorage.getItem(name);
			if (value === 'undefined')
				value = null;
		}
		return value;
	}
	
    // FROM http://purecss.io/js/ui.js
    (function (window, document) {

	
      var content = document.getElementById('main'),
		layout = document.getElementById('layout'),
        menu = document.getElementById('menu'),
        menuLink = document.getElementById('menuLink');
		
      function toggleClass(element, className) {
        var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

        for (; i < length; i++) {
          if (classes[i] === className) {
            classes.splice(i, 1);
            break;
          }
        }
        // The className is not found
        if (length === classes.length) {
          classes.push(className);
        }

        element.className = classes.join(' ');
      }

      function hasClass(element, className) {
        var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

        for (; i < length; i++) {
          if (classes[i] === className) {
            return true;
          }
        }
		return false;
      }

      menuLink.onclick = function (e) {
        var active = 'active';

        e.preventDefault();
		toggleClass(content, active);
        toggleClass(layout, active);
        toggleClass(menu, active);
        toggleClass(menuLink, active);
      };
	  
	  // Save menu scroll level when user click on link
	  var a_links = document.getElementsByTagName('a');
	  for (var i = 0 ; i < a_links.length ; i++) {
	    var link = a_links[i];
		if(menu.contains(link)) {
			link.onclick = function () {
				try {
					setData('navScroll', link.offsetTop - link.getBoundingClientRect().top);
					var root = menu.getElementsByTagName('ul')[0];
					var li_elems = root.getElementsByTagName('li');
					for (var i = 0; i<li_elems.length; i++)
					{
						if (!hasClass(li_elems[i],'collapsed'))
							setData('liexp' + i, true);
						else
							setData('liexp' + i);
					}
					setData('liexp', true);
				}
				catch (error) {
					console.error(error);
				}
				return true;
			};
		}
	  };
	  
		var root = menu.getElementsByTagName('ul')[0];
		// Remove empty ul
		var ul_elems = root.getElementsByTagName('ul');
		for (var i = ul_elems.length-1; i>=0; i--)
		{
			if (ul_elems[i].childElementCount == 0)
			{
				ul_elems[i].parentNode.removeChild(ul_elems[i]);
			}
		}
		// Restore side menu state
		var saved_state = (getData('liexp')!== null);
		var li_elems = root.getElementsByTagName('li');
		for (var i = 0; i<li_elems.length; i++)
		{
			var l = li_elems[i];
			if (hasClass(l,'heading'))
				toggleClass(l,'heading');
			if ((l.nextElementSibling) && (l.nextElementSibling.nodeName=="UL"))
			{
				toggleClass(l,'collapsible');
				var collapser = document.createElement('span');
				var inserted = l.insertBefore(collapser, l.firstChild);
				toggleClass(inserted,'collapser');
				var inserted = l.insertBefore(collapser, l.firstChild);
				inserted.addEventListener('click', function() { toggleClass(this.parentNode, 'collapsed') });
				if (saved_state)
				{
					if (getData('liexp' + i) === null)
					{
						toggleClass(l,'collapsed');
					}
				}
				else
				{
					if (l.parentNode != root)
					{
						toggleClass(l,'collapsed');
					}
				}
			}
		}
		// Restore menu scroll level if defined
		if(getData('navScroll') != null)
			document.getElementById('menu').scrollTop = getData('navScroll');

   }(this, this.document));
  </script>


</body></html>
